
                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'engine-dev/extensions/dragonbones/webgl-assembler.js';
                    var __require = nodeEnv ? function (request) {
                        return require(request);
                    } : function (request) {
                        return __quick_compile_engine__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_engine__.registerModule(__filename, module);}"use strict";

exports.__esModule = true;
exports["default"] = void 0;

var _assembler = _interopRequireDefault(require("../../cocos2d/core/renderer/assembler"));

var _mat = _interopRequireDefault(require("../../cocos2d/core/value-types/mat4"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var Armature = require('./ArmatureDisplay');

var RenderFlow = require('../../cocos2d/core/renderer/render-flow');

var gfx = cc.gfx;
var NEED_COLOR = 0x01;
var NEED_BATCH = 0x10;

var _boneColor = cc.color(255, 0, 0, 255);

var _slotColor = cc.color(0, 0, 255, 255);

var _originColor = cc.color(0, 255, 0, 255);

var _nodeR, _nodeG, _nodeB, _nodeA, _premultipliedAlpha, _multiply, _mustFlush, _buffer, _node, _renderer, _comp, _vfOffset, _indexOffset, _vertexOffset, _vertexCount, _indexCount, _x, _y, _c, _r, _g, _b, _a, _handleVal, _m00, _m04, _m12, _m01, _m05, _m13;

function _getSlotMaterial(tex, blendMode) {
  if (!tex) return null;
  var src, dst;

  switch (blendMode) {
    case 1:
      //additive
      src = _premultipliedAlpha ? cc.macro.ONE : cc.macro.SRC_ALPHA;
      dst = cc.macro.ONE;
      break;

    case 10:
      //multiply
      src = cc.macro.DST_COLOR;
      dst = cc.macro.ONE_MINUS_SRC_ALPHA;
      break;

    case 12:
      //screen
      src = cc.macro.ONE;
      dst = cc.macro.ONE_MINUS_SRC_COLOR;
      break;

    case 0: //normal

    default:
      src = _premultipliedAlpha ? cc.macro.ONE : cc.macro.SRC_ALPHA;
      dst = cc.macro.ONE_MINUS_SRC_ALPHA;
      break;
  }

  var useModel = !_comp.enableBatch;
  var baseMaterial = _comp._materials[0];

  if (!baseMaterial) {
    return null;
  }

  var materialCache = _comp._materialCache; // The key use to find corresponding material

  var key = tex.getId() + src + dst + useModel;
  var material = materialCache[key];

  if (!material) {
    if (!materialCache.baseMaterial) {
      material = baseMaterial;
      materialCache.baseMaterial = baseMaterial;
    } else {
      material = cc.MaterialVariant.create(baseMaterial);
    }

    material.define('CC_USE_MODEL', useModel);
    material.setProperty('texture', tex); // update blend function

    material.setBlend(true, gfx.BLEND_FUNC_ADD, src, dst, gfx.BLEND_FUNC_ADD, src, dst);
    materialCache[key] = material;
  }

  return material;
}

function _handleColor(color, parentOpacity) {
  _a = color.a * parentOpacity * _nodeA;
  _multiply = _premultipliedAlpha ? _a / 255.0 : 1.0;
  _r = color.r * _nodeR * _multiply;
  _g = color.g * _nodeG * _multiply;
  _b = color.b * _nodeB * _multiply;
  _c = (_a << 24 >>> 0) + (_b << 16) + (_g << 8) + _r;
}

var ArmatureAssembler =
/*#__PURE__*/
function (_Assembler) {
  _inheritsLoose(ArmatureAssembler, _Assembler);

  function ArmatureAssembler() {
    return _Assembler.apply(this, arguments) || this;
  }

  var _proto = ArmatureAssembler.prototype;

  _proto.updateRenderData = function updateRenderData(comp, batchData) {};

  _proto.realTimeTraverse = function realTimeTraverse(armature, parentMat, parentOpacity) {
    var slots = armature._slots;
    var vbuf, ibuf, uintbuf;
    var material;
    var vertices, indices;
    var slotColor;
    var slot;
    var slotMat;
    var slotMatm;
    var offsetInfo;

    for (var i = 0, l = slots.length; i < l; i++) {
      slot = slots[i];
      slotColor = slot._color;
      if (!slot._visible || !slot._displayData) continue;

      if (parentMat) {
        slot._mulMat(slot._worldMatrix, parentMat, slot._matrix);
      } else {
        _mat["default"].copy(slot._worldMatrix, slot._matrix);
      }

      if (slot.childArmature) {
        this.realTimeTraverse(slot.childArmature, slot._worldMatrix, parentOpacity * slotColor.a / 255);
        continue;
      }

      material = _getSlotMaterial(slot.getTexture(), slot._blendMode);

      if (!material) {
        continue;
      }

      if (_mustFlush || material.getHash() !== _renderer.material.getHash()) {
        _mustFlush = false;

        _renderer._flush();

        _renderer.node = _node;
        _renderer.material = material;
      }

      _handleColor(slotColor, parentOpacity);

      slotMat = slot._worldMatrix;
      slotMatm = slotMat.m;
      vertices = slot._localVertices;
      _vertexCount = vertices.length >> 2;
      indices = slot._indices;
      _indexCount = indices.length;
      offsetInfo = _buffer.request(_vertexCount, _indexCount);
      _indexOffset = offsetInfo.indiceOffset;
      _vfOffset = offsetInfo.byteOffset >> 2;
      _vertexOffset = offsetInfo.vertexOffset;
      vbuf = _buffer._vData;
      ibuf = _buffer._iData;
      uintbuf = _buffer._uintVData;
      _m00 = slotMatm[0];
      _m04 = slotMatm[4];
      _m12 = slotMatm[12];
      _m01 = slotMatm[1];
      _m05 = slotMatm[5];
      _m13 = slotMatm[13];

      for (var vi = 0, vl = vertices.length; vi < vl;) {
        _x = vertices[vi++];
        _y = vertices[vi++];
        vbuf[_vfOffset++] = _x * _m00 + _y * _m04 + _m12; // x

        vbuf[_vfOffset++] = _x * _m01 + _y * _m05 + _m13; // y

        vbuf[_vfOffset++] = vertices[vi++]; // u

        vbuf[_vfOffset++] = vertices[vi++]; // v

        uintbuf[_vfOffset++] = _c; // color
      }

      for (var ii = 0, il = indices.length; ii < il; ii++) {
        ibuf[_indexOffset++] = _vertexOffset + indices[ii];
      }
    }
  };

  _proto.cacheTraverse = function cacheTraverse(frame, parentMat) {
    if (!frame) return;
    var segments = frame.segments;
    if (segments.length == 0) return;
    var vbuf, ibuf, uintbuf;
    var material;
    var offsetInfo;
    var vertices = frame.vertices;
    var indices = frame.indices;
    var frameVFOffset = 0,
        frameIndexOffset = 0,
        segVFCount = 0;

    if (parentMat) {
      var parentMatm = parentMat.m;
      _m00 = parentMatm[0];
      _m01 = parentMatm[1];
      _m04 = parentMatm[4];
      _m05 = parentMatm[5];
      _m12 = parentMatm[12];
      _m13 = parentMatm[13];
    }

    var justTranslate = _m00 === 1 && _m01 === 0 && _m04 === 0 && _m05 === 1;
    var needBatch = _handleVal & NEED_BATCH;
    var calcTranslate = needBatch && justTranslate;
    var colorOffset = 0;
    var colors = frame.colors;
    var nowColor = colors[colorOffset++];
    var maxVFOffset = nowColor.vfOffset;

    _handleColor(nowColor, 1.0);

    for (var i = 0, n = segments.length; i < n; i++) {
      var segInfo = segments[i];
      material = _getSlotMaterial(segInfo.tex, segInfo.blendMode);

      if (_mustFlush || material.getHash() !== _renderer.material.getHash()) {
        _mustFlush = false;

        _renderer._flush();

        _renderer.node = _node;
        _renderer.material = material;
      }

      _vertexCount = segInfo.vertexCount;
      _indexCount = segInfo.indexCount;
      offsetInfo = _buffer.request(_vertexCount, _indexCount);
      _indexOffset = offsetInfo.indiceOffset;
      _vertexOffset = offsetInfo.vertexOffset;
      _vfOffset = offsetInfo.byteOffset >> 2;
      vbuf = _buffer._vData;
      ibuf = _buffer._iData;
      uintbuf = _buffer._uintVData;

      for (var ii = _indexOffset, il = _indexOffset + _indexCount; ii < il; ii++) {
        ibuf[ii] = _vertexOffset + indices[frameIndexOffset++];
      }

      segVFCount = segInfo.vfCount;
      vbuf.set(vertices.subarray(frameVFOffset, frameVFOffset + segVFCount), _vfOffset);
      frameVFOffset += segVFCount;

      if (calcTranslate) {
        for (var _ii = _vfOffset, _il = _vfOffset + segVFCount; _ii < _il; _ii += 5) {
          vbuf[_ii] += _m12;
          vbuf[_ii + 1] += _m13;
        }
      } else if (needBatch) {
        for (var _ii2 = _vfOffset, _il2 = _vfOffset + segVFCount; _ii2 < _il2; _ii2 += 5) {
          _x = vbuf[_ii2];
          _y = vbuf[_ii2 + 1];
          vbuf[_ii2] = _x * _m00 + _y * _m04 + _m12;
          vbuf[_ii2 + 1] = _x * _m01 + _y * _m05 + _m13;
        }
      }

      if (!(_handleVal & NEED_COLOR)) continue; // handle color

      var frameColorOffset = frameVFOffset - segVFCount;

      for (var _ii3 = _vfOffset + 4, _il3 = _vfOffset + 4 + segVFCount; _ii3 < _il3; _ii3 += 5, frameColorOffset += 5) {
        if (frameColorOffset >= maxVFOffset) {
          nowColor = colors[colorOffset++];

          _handleColor(nowColor, 1.0);

          maxVFOffset = nowColor.vfOffset;
        }

        uintbuf[_ii3] = _c;
      }
    }
  };

  _proto.fillBuffers = function fillBuffers(comp, renderer) {
    comp.node._renderFlag |= RenderFlow.FLAG_UPDATE_RENDER_DATA;
    var armature = comp._armature;
    if (!armature) return; // Init temp var.

    _mustFlush = true;
    _premultipliedAlpha = comp.premultipliedAlpha;
    _node = comp.node;
    _buffer = renderer._meshBuffer;
    _renderer = renderer;
    _comp = comp;
    _handleVal = 0;
    var nodeColor = _node._color;
    _nodeR = nodeColor.r / 255;
    _nodeG = nodeColor.g / 255;
    _nodeB = nodeColor.b / 255;
    _nodeA = nodeColor.a / 255;

    if (nodeColor._val !== 0xffffffff) {
      _handleVal |= NEED_COLOR;
    }

    var worldMat = undefined;

    if (_comp.enableBatch) {
      worldMat = _node._worldMatrix;
      _mustFlush = false;
      _handleVal |= NEED_BATCH;
    }

    if (comp.isAnimationCached()) {
      // Traverse input assembler.
      this.cacheTraverse(comp._curFrame, worldMat);
    } else {
      // Traverse all armature.
      this.realTimeTraverse(armature, worldMat, 1.0);
      var graphics = comp._debugDraw;

      if (comp.debugBones && graphics) {
        graphics.clear();
        graphics.lineWidth = 5;
        graphics.strokeColor = _boneColor;
        graphics.fillColor = _slotColor; // Root bone color is same as slot color.

        var bones = armature.getBones();

        for (var i = 0, l = bones.length; i < l; i++) {
          var bone = bones[i];
          var boneLength = Math.max(bone.boneData.length, 5);
          var startX = bone.globalTransformMatrix.tx;
          var startY = bone.globalTransformMatrix.ty;
          var endX = startX + bone.globalTransformMatrix.a * boneLength;
          var endY = startY + bone.globalTransformMatrix.b * boneLength;
          graphics.moveTo(startX, startY);
          graphics.lineTo(endX, endY);
          graphics.stroke(); // Bone origins.

          graphics.circle(startX, startY, Math.PI * 2);
          graphics.fill();

          if (i === 0) {
            graphics.fillColor = _originColor;
          }
        }
      }
    } // sync attached node matrix


    renderer.worldMatDirty++;

    comp.attachUtil._syncAttachedNode(); // Clear temp var.


    _node = undefined;
    _buffer = undefined;
    _renderer = undefined;
    _comp = undefined;
  };

  _proto.postFillBuffers = function postFillBuffers(comp, renderer) {
    renderer.worldMatDirty--;
  };

  return ArmatureAssembler;
}(_assembler["default"]);

exports["default"] = ArmatureAssembler;

_assembler["default"].register(Armature, ArmatureAssembler);

module.exports = exports["default"];
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_engine__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYmdsLWFzc2VtYmxlci5qcyJdLCJuYW1lcyI6WyJBcm1hdHVyZSIsInJlcXVpcmUiLCJSZW5kZXJGbG93IiwiZ2Z4IiwiY2MiLCJORUVEX0NPTE9SIiwiTkVFRF9CQVRDSCIsIl9ib25lQ29sb3IiLCJjb2xvciIsIl9zbG90Q29sb3IiLCJfb3JpZ2luQ29sb3IiLCJfbm9kZVIiLCJfbm9kZUciLCJfbm9kZUIiLCJfbm9kZUEiLCJfcHJlbXVsdGlwbGllZEFscGhhIiwiX211bHRpcGx5IiwiX211c3RGbHVzaCIsIl9idWZmZXIiLCJfbm9kZSIsIl9yZW5kZXJlciIsIl9jb21wIiwiX3ZmT2Zmc2V0IiwiX2luZGV4T2Zmc2V0IiwiX3ZlcnRleE9mZnNldCIsIl92ZXJ0ZXhDb3VudCIsIl9pbmRleENvdW50IiwiX3giLCJfeSIsIl9jIiwiX3IiLCJfZyIsIl9iIiwiX2EiLCJfaGFuZGxlVmFsIiwiX20wMCIsIl9tMDQiLCJfbTEyIiwiX20wMSIsIl9tMDUiLCJfbTEzIiwiX2dldFNsb3RNYXRlcmlhbCIsInRleCIsImJsZW5kTW9kZSIsInNyYyIsImRzdCIsIm1hY3JvIiwiT05FIiwiU1JDX0FMUEhBIiwiRFNUX0NPTE9SIiwiT05FX01JTlVTX1NSQ19BTFBIQSIsIk9ORV9NSU5VU19TUkNfQ09MT1IiLCJ1c2VNb2RlbCIsImVuYWJsZUJhdGNoIiwiYmFzZU1hdGVyaWFsIiwiX21hdGVyaWFscyIsIm1hdGVyaWFsQ2FjaGUiLCJfbWF0ZXJpYWxDYWNoZSIsImtleSIsImdldElkIiwibWF0ZXJpYWwiLCJNYXRlcmlhbFZhcmlhbnQiLCJjcmVhdGUiLCJkZWZpbmUiLCJzZXRQcm9wZXJ0eSIsInNldEJsZW5kIiwiQkxFTkRfRlVOQ19BREQiLCJfaGFuZGxlQ29sb3IiLCJwYXJlbnRPcGFjaXR5IiwiYSIsInIiLCJnIiwiYiIsIkFybWF0dXJlQXNzZW1ibGVyIiwidXBkYXRlUmVuZGVyRGF0YSIsImNvbXAiLCJiYXRjaERhdGEiLCJyZWFsVGltZVRyYXZlcnNlIiwiYXJtYXR1cmUiLCJwYXJlbnRNYXQiLCJzbG90cyIsIl9zbG90cyIsInZidWYiLCJpYnVmIiwidWludGJ1ZiIsInZlcnRpY2VzIiwiaW5kaWNlcyIsInNsb3RDb2xvciIsInNsb3QiLCJzbG90TWF0Iiwic2xvdE1hdG0iLCJvZmZzZXRJbmZvIiwiaSIsImwiLCJsZW5ndGgiLCJfY29sb3IiLCJfdmlzaWJsZSIsIl9kaXNwbGF5RGF0YSIsIl9tdWxNYXQiLCJfd29ybGRNYXRyaXgiLCJfbWF0cml4IiwiTWF0NCIsImNvcHkiLCJjaGlsZEFybWF0dXJlIiwiZ2V0VGV4dHVyZSIsIl9ibGVuZE1vZGUiLCJnZXRIYXNoIiwiX2ZsdXNoIiwibm9kZSIsIm0iLCJfbG9jYWxWZXJ0aWNlcyIsIl9pbmRpY2VzIiwicmVxdWVzdCIsImluZGljZU9mZnNldCIsImJ5dGVPZmZzZXQiLCJ2ZXJ0ZXhPZmZzZXQiLCJfdkRhdGEiLCJfaURhdGEiLCJfdWludFZEYXRhIiwidmkiLCJ2bCIsImlpIiwiaWwiLCJjYWNoZVRyYXZlcnNlIiwiZnJhbWUiLCJzZWdtZW50cyIsImZyYW1lVkZPZmZzZXQiLCJmcmFtZUluZGV4T2Zmc2V0Iiwic2VnVkZDb3VudCIsInBhcmVudE1hdG0iLCJqdXN0VHJhbnNsYXRlIiwibmVlZEJhdGNoIiwiY2FsY1RyYW5zbGF0ZSIsImNvbG9yT2Zmc2V0IiwiY29sb3JzIiwibm93Q29sb3IiLCJtYXhWRk9mZnNldCIsInZmT2Zmc2V0IiwibiIsInNlZ0luZm8iLCJ2ZXJ0ZXhDb3VudCIsImluZGV4Q291bnQiLCJ2ZkNvdW50Iiwic2V0Iiwic3ViYXJyYXkiLCJmcmFtZUNvbG9yT2Zmc2V0IiwiZmlsbEJ1ZmZlcnMiLCJyZW5kZXJlciIsIl9yZW5kZXJGbGFnIiwiRkxBR19VUERBVEVfUkVOREVSX0RBVEEiLCJfYXJtYXR1cmUiLCJwcmVtdWx0aXBsaWVkQWxwaGEiLCJfbWVzaEJ1ZmZlciIsIm5vZGVDb2xvciIsIl92YWwiLCJ3b3JsZE1hdCIsInVuZGVmaW5lZCIsImlzQW5pbWF0aW9uQ2FjaGVkIiwiX2N1ckZyYW1lIiwiZ3JhcGhpY3MiLCJfZGVidWdEcmF3IiwiZGVidWdCb25lcyIsImNsZWFyIiwibGluZVdpZHRoIiwic3Ryb2tlQ29sb3IiLCJmaWxsQ29sb3IiLCJib25lcyIsImdldEJvbmVzIiwiYm9uZSIsImJvbmVMZW5ndGgiLCJNYXRoIiwibWF4IiwiYm9uZURhdGEiLCJzdGFydFgiLCJnbG9iYWxUcmFuc2Zvcm1NYXRyaXgiLCJ0eCIsInN0YXJ0WSIsInR5IiwiZW5kWCIsImVuZFkiLCJtb3ZlVG8iLCJsaW5lVG8iLCJzdHJva2UiLCJjaXJjbGUiLCJQSSIsImZpbGwiLCJ3b3JsZE1hdERpcnR5IiwiYXR0YWNoVXRpbCIsIl9zeW5jQXR0YWNoZWROb2RlIiwicG9zdEZpbGxCdWZmZXJzIiwiQXNzZW1ibGVyIiwicmVnaXN0ZXIiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUF5QkE7O0FBQ0E7Ozs7OztBQUVBLElBQU1BLFFBQVEsR0FBR0MsT0FBTyxDQUFDLG1CQUFELENBQXhCOztBQUNBLElBQU1DLFVBQVUsR0FBR0QsT0FBTyxDQUFDLHlDQUFELENBQTFCOztBQUNBLElBQU1FLEdBQUcsR0FBR0MsRUFBRSxDQUFDRCxHQUFmO0FBQ0EsSUFBTUUsVUFBVSxHQUFHLElBQW5CO0FBQ0EsSUFBTUMsVUFBVSxHQUFHLElBQW5COztBQUVBLElBQUlDLFVBQVUsR0FBR0gsRUFBRSxDQUFDSSxLQUFILENBQVMsR0FBVCxFQUFjLENBQWQsRUFBaUIsQ0FBakIsRUFBb0IsR0FBcEIsQ0FBakI7O0FBQ0EsSUFBSUMsVUFBVSxHQUFHTCxFQUFFLENBQUNJLEtBQUgsQ0FBUyxDQUFULEVBQVksQ0FBWixFQUFlLEdBQWYsRUFBb0IsR0FBcEIsQ0FBakI7O0FBQ0EsSUFBSUUsWUFBWSxHQUFHTixFQUFFLENBQUNJLEtBQUgsQ0FBUyxDQUFULEVBQVksR0FBWixFQUFpQixDQUFqQixFQUFvQixHQUFwQixDQUFuQjs7QUFFQSxJQUFJRyxNQUFKLEVBQVlDLE1BQVosRUFBb0JDLE1BQXBC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LENBQUNnSCxVQUFMLENBQWdCQyxpQkFBaEIsR0F2RXlCLENBeUV6Qjs7O0FBQ0F6SyxJQUFBQSxLQUFLLEdBQUd5SSxTQUFSO0FBQ0ExSSxJQUFBQSxPQUFPLEdBQUcwSSxTQUFWO0FBQ0F4SSxJQUFBQSxTQUFTLEdBQUd3SSxTQUFaO0FBQ0F2SSxJQUFBQSxLQUFLLEdBQUd1SSxTQUFSO0FBQ0g7O1NBRURpQyxrQkFBQSx5QkFBaUJsSCxJQUFqQixFQUF1QndFLFFBQXZCLEVBQWlDO0FBQzdCQSxJQUFBQSxRQUFRLENBQUN1QyxhQUFUO0FBQ0g7OztFQWxRMENJOzs7O0FBcVEvQ0Esc0JBQVVDLFFBQVYsQ0FBbUIvTCxRQUFuQixFQUE2QnlFLGlCQUE3QiIsInNvdXJjZXNDb250ZW50IjpbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gQ29weXJpZ2h0IChjKSAyMDE3LTIwMTggWGlhbWVuIFlhamkgU29mdHdhcmUgQ28uLCBMdGQuXG5cbiBodHRwczovL3d3dy5jb2Nvcy5jb20vXG5cbiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBlbmdpbmUgc291cmNlIGNvZGUgKHRoZSBcIlNvZnR3YXJlXCIpLCBhIGxpbWl0ZWQsXG4gd29ybGR3aWRlLCByb3lhbHR5LWZyZWUsIG5vbi1hc3NpZ25hYmxlLCByZXZvY2FibGUgYW5kIG5vbi1leGNsdXNpdmUgbGljZW5zZVxuIHRvIHVzZSBDb2NvcyBDcmVhdG9yIHNvbGVseSB0byBkZXZlbG9wIGdhbWVzIG9uIHlvdXIgdGFyZ2V0IHBsYXRmb3Jtcy4gWW91IHNoYWxsXG4gbm90IHVzZSBDb2NvcyBDcmVhdG9yIHNvZnR3YXJlIGZvciBkZXZlbG9waW5nIG90aGVyIHNvZnR3YXJlIG9yIHRvb2xzIHRoYXQnc1xuIHVzZWQgZm9yIGRldmVsb3BpbmcgZ2FtZXMuIFlvdSBhcmUgbm90IGdyYW50ZWQgdG8gcHVibGlzaCwgZGlzdHJpYnV0ZSxcbiBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgQ29jb3MgQ3JlYXRvci5cblxuIFRoZSBzb2Z0d2FyZSBvciB0b29scyBpbiB0aGlzIExpY2Vuc2UgQWdyZWVtZW50IGFyZSBsaWNlbnNlZCwgbm90IHNvbGQuXG4gWGlhbWVuIFlhamkgU29mdHdhcmUgQ28uLCBMdGQuIHJlc2VydmVzIGFsbCByaWdodHMgbm90IGV4cHJlc3NseSBncmFudGVkIHRvIHlvdS5cblxuIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gVEhFIFNPRlRXQVJFLlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbmltcG9ydCBBc3NlbWJsZXIgZnJvbSAnLi4vLi4vY29jb3MyZC9jb3JlL3JlbmRlcmVyL2Fzc2VtYmxlcic7XG5pbXBvcnQgTWF0NCBmcm9tICcuLi8uLi9jb2NvczJkL2NvcmUvdmFsdWUtdHlwZXMvbWF0NCc7XG5cbmNvbnN0IEFybWF0dXJlID0gcmVxdWlyZSgnLi9Bcm1hdHVyZURpc3BsYXknKTtcbmNvbnN0IFJlbmRlckZsb3cgPSByZXF1aXJlKCcuLi8uLi9jb2NvczJkL2NvcmUvcmVuZGVyZXIvcmVuZGVyLWZsb3cnKTtcbmNvbnN0IGdmeCA9IGNjLmdmeDtcbmNvbnN0IE5FRURfQ09MT1IgPSAweDAxO1xuY29uc3QgTkVFRF9CQVRDSCA9IDB4MTA7XG5cbmxldCBfYm9uZUNvbG9yID0gY2MuY29sb3IoMjU1LCAwLCAwLCAyNTUpO1xubGV0IF9zbG90Q29sb3IgPSBjYy5jb2xvcigwLCAwLCAyNTUsIDI1NSk7XG5sZXQgX29yaWdpbkNvbG9yID0gY2MuY29sb3IoMCwgMjU1LCAwLCAyNTUpO1xuXG5sZXQgX25vZGVSLCBfbm9kZUcsIF9ub2RlQiwgX25vZGVBLFxuICAgIF9wcmVtdWx0aXBsaWVkQWxwaGEsIF9tdWx0aXBseSxcbiAgICBfbXVzdEZsdXNoLCBfYnVmZmVyLCBfbm9kZSxcbiAgICBfcmVuZGVyZXIsIF9jb21wLFxuICAgIF92Zk9mZnNldCwgX2luZGV4T2Zmc2V0LCBfdmVydGV4T2Zmc2V0LFxuICAgIF92ZXJ0ZXhDb3VudCwgX2luZGV4Q291bnQsXG4gICAgX3gsIF95LCBfYywgX3IsIF9nLCBfYiwgX2EsIF9oYW5kbGVWYWwsXG4gICAgX20wMCwgX20wNCwgX20xMixcbiAgICBfbTAxLCBfbTA1LCBfbTEzO1xuXG5mdW5jdGlvbiBfZ2V0U2xvdE1hdGVyaWFsICh0ZXgsIGJsZW5kTW9kZSkge1xuICAgIGlmKCF0ZXgpcmV0dXJuIG51bGw7XG5cbiAgICBsZXQgc3JjLCBkc3Q7XG4gICAgc3dpdGNoIChibGVuZE1vZGUpIHtcbiAgICAgICAgY2FzZSAxOi8vYWRkaXRpdmVcbiAgICAgICAgICAgIHNyYyA9IF9wcmVtdWx0aXBsaWVkQWxwaGEgPyBjYy5tYWNyby5PTkUgOiBjYy5tYWNyby5TUkNfQUxQSEE7XG4gICAgICAgICAgICBkc3QgPSBjYy5tYWNyby5PTkU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMDovL211bHRpcGx5XG4gICAgICAgICAgICBzcmMgPSBjYy5tYWNyby5EU1RfQ09MT1I7XG4gICAgICAgICAgICBkc3QgPSBjYy5tYWNyby5PTkVfTUlOVVNfU1JDX0FMUEhBO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTI6Ly9zY3JlZW5cbiAgICAgICAgICAgIHNyYyA9IGNjLm1hY3JvLk9ORTtcbiAgICAgICAgICAgIGRzdCA9IGNjLm1hY3JvLk9ORV9NSU5VU19TUkNfQ09MT1I7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAwOi8vbm9ybWFsXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBzcmMgPSBfcHJlbXVsdGlwbGllZEFscGhhID8gY2MubWFjcm8uT05FIDogY2MubWFjcm8uU1JDX0FMUEhBO1xuICAgICAgICAgICAgZHN0ID0gY2MubWFjcm8uT05FX01JTlVTX1NSQ19BTFBIQTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGxldCB1c2VNb2RlbCA9ICFfY29tcC5lbmFibGVCYXRjaDtcbiAgICBsZXQgYmFzZU1hdGVyaWFsID0gX2NvbXAuX21hdGVyaWFsc1swXTtcbiAgICBpZiAoIWJhc2VNYXRlcmlhbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgbGV0IG1hdGVyaWFsQ2FjaGUgPSBfY29tcC5fbWF0ZXJpYWxDYWNoZTtcblxuICAgIC8vIFRoZSBrZXkgdXNlIHRvIGZpbmQgY29ycmVzcG9uZGluZyBtYXRlcmlhbFxuICAgIGxldCBrZXkgPSB0ZXguZ2V0SWQoKSArIHNyYyArIGRzdCArIHVzZU1vZGVsO1xuICAgIGxldCBtYXRlcmlhbCA9IG1hdGVyaWFsQ2FjaGVba2V5XTtcbiAgICBpZiAoIW1hdGVyaWFsKSB7XG4gICAgICAgIGlmICghbWF0ZXJpYWxDYWNoZS5iYXNlTWF0ZXJpYWwpIHtcbiAgICAgICAgICAgIG1hdGVyaWFsID0gYmFzZU1hdGVyaWFsO1xuICAgICAgICAgICAgbWF0ZXJpYWxDYWNoZS5iYXNlTWF0ZXJpYWwgPSBiYXNlTWF0ZXJpYWw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXRlcmlhbCA9IGNjLk1hdGVyaWFsVmFyaWFudC5jcmVhdGUoYmFzZU1hdGVyaWFsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1hdGVyaWFsLmRlZmluZSgnQ0NfVVNFX01PREVMJywgdXNlTW9kZWwpO1xuICAgICAgICBtYXRlcmlhbC5zZXRQcm9wZXJ0eSgndGV4dHVyZScsIHRleCk7XG5cbiAgICAgICAgLy8gdXBkYXRlIGJsZW5kIGZ1bmN0aW9uXG4gICAgICAgIG1hdGVyaWFsLnNldEJsZW5kKFxuICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgIGdmeC5CTEVORF9GVU5DX0FERCxcbiAgICAgICAgICAgIHNyYywgZHN0LFxuICAgICAgICAgICAgZ2Z4LkJMRU5EX0ZVTkNfQURELFxuICAgICAgICAgICAgc3JjLCBkc3RcbiAgICAgICAgKTtcbiAgICAgICAgbWF0ZXJpYWxDYWNoZVtrZXldID0gbWF0ZXJpYWw7XG4gICAgfVxuICAgIHJldHVybiBtYXRlcmlhbDtcbn1cblxuZnVuY3Rpb24gX2hhbmRsZUNvbG9yIChjb2xvciwgcGFyZW50T3BhY2l0eSkge1xuICAgIF9hID0gY29sb3IuYSAqIHBhcmVudE9wYWNpdHkgKiBfbm9kZUE7XG4gICAgX211bHRpcGx5ID0gX3ByZW11bHRpcGxpZWRBbHBoYT8gX2EgLyAyNTUuMCA6IDEuMDtcbiAgICBfciA9IGNvbG9yLnIgKiBfbm9kZVIgKiBfbXVsdGlwbHk7XG4gICAgX2cgPSBjb2xvci5nICogX25vZGVHICogX211bHRpcGx5O1xuICAgIF9iID0gY29sb3IuYiAqIF9ub2RlQiAqIF9tdWx0aXBseTtcbiAgICBfYyA9ICgoX2E8PDI0KSA+Pj4gMCkgKyAoX2I8PDE2KSArIChfZzw8OCkgKyBfcjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXJtYXR1cmVBc3NlbWJsZXIgZXh0ZW5kcyBBc3NlbWJsZXIge1xuICAgIHVwZGF0ZVJlbmRlckRhdGEgKGNvbXAsIGJhdGNoRGF0YSkge31cblxuICAgIHJlYWxUaW1lVHJhdmVyc2UgKGFybWF0dXJlLCBwYXJlbnRNYXQsIHBhcmVudE9wYWNpdHkpIHtcbiAgICAgICAgbGV0IHNsb3RzID0gYXJtYXR1cmUuX3Nsb3RzO1xuICAgICAgICBsZXQgdmJ1ZiwgaWJ1ZiwgdWludGJ1ZjtcbiAgICAgICAgbGV0IG1hdGVyaWFsO1xuICAgICAgICBsZXQgdmVydGljZXMsIGluZGljZXM7XG4gICAgICAgIGxldCBzbG90Q29sb3I7XG4gICAgICAgIGxldCBzbG90O1xuICAgICAgICBsZXQgc2xvdE1hdDtcbiAgICAgICAgbGV0IHNsb3RNYXRtO1xuICAgICAgICBsZXQgb2Zmc2V0SW5mbztcblxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IHNsb3RzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgc2xvdCA9IHNsb3RzW2ldO1xuICAgICAgICAgICAgc2xvdENvbG9yID0gc2xvdC5fY29sb3I7XG5cbiAgICAgICAgICAgIGlmICghc2xvdC5fdmlzaWJsZSB8fCAhc2xvdC5fZGlzcGxheURhdGEpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBpZiAocGFyZW50TWF0KSB7XG4gICAgICAgICAgICAgICAgc2xvdC5fbXVsTWF0KHNsb3QuX3dvcmxkTWF0cml4LCBwYXJlbnRNYXQsIHNsb3QuX21hdHJpeCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIE1hdDQuY29weShzbG90Ll93b3JsZE1hdHJpeCwgc2xvdC5fbWF0cml4KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNsb3QuY2hpbGRBcm1hdHVyZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVhbFRpbWVUcmF2ZXJzZShzbG90LmNoaWxkQXJtYXR1cmUsIHNsb3QuX3dvcmxkTWF0cml4LCBwYXJlbnRPcGFjaXR5ICogc2xvdENvbG9yLmEgLyAyNTUpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtYXRlcmlhbCA9IF9nZXRTbG90TWF0ZXJpYWwoc2xvdC5nZXRUZXh0dXJlKCksIHNsb3QuX2JsZW5kTW9kZSk7XG4gICAgICAgICAgICBpZiAoIW1hdGVyaWFsKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChfbXVzdEZsdXNoIHx8IG1hdGVyaWFsLmdldEhhc2goKSAhPT0gX3JlbmRlcmVyLm1hdGVyaWFsLmdldEhhc2goKSkge1xuICAgICAgICAgICAgICAgIF9tdXN0Rmx1c2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBfcmVuZGVyZXIuX2ZsdXNoKCk7XG4gICAgICAgICAgICAgICAgX3JlbmRlcmVyLm5vZGUgPSBfbm9kZTtcbiAgICAgICAgICAgICAgICBfcmVuZGVyZXIubWF0ZXJpYWwgPSBtYXRlcmlhbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2hhbmRsZUNvbG9yKHNsb3RDb2xvciwgcGFyZW50T3BhY2l0eSk7XG4gICAgICAgICAgICBzbG90TWF0ID0gc2xvdC5fd29ybGRNYXRyaXg7XG4gICAgICAgICAgICBzbG90TWF0bSA9IHNsb3RNYXQubTtcblxuICAgICAgICAgICAgdmVydGljZXMgPSBzbG90Ll9sb2NhbFZlcnRpY2VzO1xuICAgICAgICAgICAgX3ZlcnRleENvdW50ID0gdmVydGljZXMubGVuZ3RoID4+IDI7XG5cbiAgICAgICAgICAgIGluZGljZXMgPSBzbG90Ll9pbmRpY2VzO1xuICAgICAgICAgICAgX2luZGV4Q291bnQgPSBpbmRpY2VzLmxlbmd0aDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgb2Zmc2V0SW5mbyA9IF9idWZmZXIucmVxdWVzdChfdmVydGV4Q291bnQsIF9pbmRleENvdW50KTtcbiAgICAgICAgICAgIF9pbmRleE9mZnNldCA9IG9mZnNldEluZm8uaW5kaWNlT2Zmc2V0O1xuICAgICAgICAgICAgX3ZmT2Zmc2V0ID0gb2Zmc2V0SW5mby5ieXRlT2Zmc2V0ID4+IDI7XG4gICAgICAgICAgICBfdmVydGV4T2Zmc2V0ID0gb2Zmc2V0SW5mby52ZXJ0ZXhPZmZzZXQ7XG4gICAgICAgICAgICB2YnVmID0gX2J1ZmZlci5fdkRhdGE7XG4gICAgICAgICAgICBpYnVmID0gX2J1ZmZlci5faURhdGE7XG4gICAgICAgICAgICB1aW50YnVmID0gX2J1ZmZlci5fdWludFZEYXRhO1xuXG4gICAgICAgICAgICBfbTAwID0gc2xvdE1hdG1bMF07XG4gICAgICAgICAgICBfbTA0ID0gc2xvdE1hdG1bNF07XG4gICAgICAgICAgICBfbTEyID0gc2xvdE1hdG1bMTJdO1xuICAgICAgICAgICAgX20wMSA9IHNsb3RNYXRtWzFdO1xuICAgICAgICAgICAgX20wNSA9IHNsb3RNYXRtWzVdO1xuICAgICAgICAgICAgX20xMyA9IHNsb3RNYXRtWzEzXTtcblxuICAgICAgICAgICAgZm9yIChsZXQgdmkgPSAwLCB2bCA9IHZlcnRpY2VzLmxlbmd0aDsgdmkgPCB2bDspIHtcbiAgICAgICAgICAgICAgICBfeCA9IHZlcnRpY2VzW3ZpKytdOyBcbiAgICAgICAgICAgICAgICBfeSA9IHZlcnRpY2VzW3ZpKytdO1xuXG4gICAgICAgICAgICAgICAgdmJ1ZltfdmZPZmZzZXQrK10gPSBfeCAqIF9tMDAgKyBfeSAqIF9tMDQgKyBfbTEyOyAvLyB4XG4gICAgICAgICAgICAgICAgdmJ1ZltfdmZPZmZzZXQrK10gPSBfeCAqIF9tMDEgKyBfeSAqIF9tMDUgKyBfbTEzOyAvLyB5XG5cbiAgICAgICAgICAgICAgICB2YnVmW192Zk9mZnNldCsrXSA9IHZlcnRpY2VzW3ZpKytdOyAvLyB1XG4gICAgICAgICAgICAgICAgdmJ1ZltfdmZPZmZzZXQrK10gPSB2ZXJ0aWNlc1t2aSsrXTsgLy8gdlxuICAgICAgICAgICAgICAgIHVpbnRidWZbX3ZmT2Zmc2V0KytdID0gX2M7IC8vIGNvbG9yXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAobGV0IGlpID0gMCwgaWwgPSBpbmRpY2VzLmxlbmd0aDsgaWkgPCBpbDsgaWkgKyspIHtcbiAgICAgICAgICAgICAgICBpYnVmW19pbmRleE9mZnNldCsrXSA9IF92ZXJ0ZXhPZmZzZXQgKyBpbmRpY2VzW2lpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNhY2hlVHJhdmVyc2UgKGZyYW1lLCBwYXJlbnRNYXQpIHtcbiAgICAgICAgaWYgKCFmcmFtZSkgcmV0dXJuO1xuICAgICAgICBsZXQgc2VnbWVudHMgPSBmcmFtZS5zZWdtZW50cztcbiAgICAgICAgaWYgKHNlZ21lbnRzLmxlbmd0aCA9PSAwKSByZXR1cm47XG5cbiAgICAgICAgbGV0IHZidWYsIGlidWYsIHVpbnRidWY7XG4gICAgICAgIGxldCBtYXRlcmlhbDtcbiAgICAgICAgbGV0IG9mZnNldEluZm87XG4gICAgICAgIGxldCB2ZXJ0aWNlcyA9IGZyYW1lLnZlcnRpY2VzO1xuICAgICAgICBsZXQgaW5kaWNlcyA9IGZyYW1lLmluZGljZXM7XG4gICAgICAgIFxuICAgICAgICBsZXQgZnJhbWVWRk9mZnNldCA9IDAsIGZyYW1lSW5kZXhPZmZzZXQgPSAwLCBzZWdWRkNvdW50ID0gMDtcbiAgICAgICAgaWYgKHBhcmVudE1hdCkge1xuICAgICAgICAgICAgbGV0IHBhcmVudE1hdG0gPSBwYXJlbnRNYXQubTtcbiAgICAgICAgICAgIF9tMDAgPSBwYXJlbnRNYXRtWzBdO1xuICAgICAgICAgICAgX20wMSA9IHBhcmVudE1hdG1bMV07XG4gICAgICAgICAgICBfbTA0ID0gcGFyZW50TWF0bVs0XTtcbiAgICAgICAgICAgIF9tMDUgPSBwYXJlbnRNYXRtWzVdO1xuICAgICAgICAgICAgX20xMiA9IHBhcmVudE1hdG1bMTJdO1xuICAgICAgICAgICAgX20xMyA9IHBhcmVudE1hdG1bMTNdO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGp1c3RUcmFuc2xhdGUgPSBfbTAwID09PSAxICYmIF9tMDEgPT09IDAgJiYgX20wNCA9PT0gMCAmJiBfbTA1ID09PSAxO1xuICAgICAgICBsZXQgbmVlZEJhdGNoID0gKF9oYW5kbGVWYWwgJiBORUVEX0JBVENIKTtcbiAgICAgICAgbGV0IGNhbGNUcmFuc2xhdGUgPSBuZWVkQmF0Y2ggJiYganVzdFRyYW5zbGF0ZTtcblxuICAgICAgICBsZXQgY29sb3JPZmZzZXQgPSAwO1xuICAgICAgICBsZXQgY29sb3JzID0gZnJhbWUuY29sb3JzO1xuICAgICAgICBsZXQgbm93Q29sb3IgPSBjb2xvcnNbY29sb3JPZmZzZXQrK107XG4gICAgICAgIGxldCBtYXhWRk9mZnNldCA9IG5vd0NvbG9yLnZmT2Zmc2V0O1xuICAgICAgICBfaGFuZGxlQ29sb3Iobm93Q29sb3IsIDEuMCk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzZWdJbmZvID0gc2VnbWVudHNbaV07XG4gICAgICAgICAgICBtYXRlcmlhbCA9IF9nZXRTbG90TWF0ZXJpYWwoc2VnSW5mby50ZXgsIHNlZ0luZm8uYmxlbmRNb2RlKTtcbiAgICAgICAgICAgIGlmIChfbXVzdEZsdXNoIHx8IG1hdGVyaWFsLmdldEhhc2goKSAhPT0gX3JlbmRlcmVyLm1hdGVyaWFsLmdldEhhc2goKSkge1xuICAgICAgICAgICAgICAgIF9tdXN0Rmx1c2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBfcmVuZGVyZXIuX2ZsdXNoKCk7XG4gICAgICAgICAgICAgICAgX3JlbmRlcmVyLm5vZGUgPSBfbm9kZTtcbiAgICAgICAgICAgICAgICBfcmVuZGVyZXIubWF0ZXJpYWwgPSBtYXRlcmlhbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX3ZlcnRleENvdW50ID0gc2VnSW5mby52ZXJ0ZXhDb3VudDtcbiAgICAgICAgICAgIF9pbmRleENvdW50ID0gc2VnSW5mby5pbmRleENvdW50O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBvZmZzZXRJbmZvID0gX2J1ZmZlci5yZXF1ZXN0KF92ZXJ0ZXhDb3VudCwgX2luZGV4Q291bnQpO1xuICAgICAgICAgICAgX2luZGV4T2Zmc2V0ID0gb2Zmc2V0SW5mby5pbmRpY2VPZmZzZXQ7XG4gICAgICAgICAgICBfdmVydGV4T2Zmc2V0ID0gb2Zmc2V0SW5mby52ZXJ0ZXhPZmZzZXQ7XG4gICAgICAgICAgICBfdmZPZmZzZXQgPSBvZmZzZXRJbmZvLmJ5dGVPZmZzZXQgPj4gMjtcbiAgICAgICAgICAgIHZidWYgPSBfYnVmZmVyLl92RGF0YTtcbiAgICAgICAgICAgIGlidWYgPSBfYnVmZmVyLl9pRGF0YTtcbiAgICAgICAgICAgIHVpbnRidWYgPSBfYnVmZmVyLl91aW50VkRhdGE7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGlpID0gX2luZGV4T2Zmc2V0LCBpbCA9IF9pbmRleE9mZnNldCArIF9pbmRleENvdW50OyBpaSA8IGlsOyBpaSsrKSB7XG4gICAgICAgICAgICAgICAgaWJ1ZltpaV0gPSBfdmVydGV4T2Zmc2V0ICsgaW5kaWNlc1tmcmFtZUluZGV4T2Zmc2V0KytdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWdWRkNvdW50ID0gc2VnSW5mby52ZkNvdW50O1xuICAgICAgICAgICAgdmJ1Zi5zZXQodmVydGljZXMuc3ViYXJyYXkoZnJhbWVWRk9mZnNldCwgZnJhbWVWRk9mZnNldCArIHNlZ1ZGQ291bnQpLCBfdmZPZmZzZXQpO1xuICAgICAgICAgICAgZnJhbWVWRk9mZnNldCArPSBzZWdWRkNvdW50O1xuXG4gICAgICAgICAgICBpZiAoY2FsY1RyYW5zbGF0ZSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGlpID0gX3ZmT2Zmc2V0LCBpbCA9IF92Zk9mZnNldCArIHNlZ1ZGQ291bnQ7IGlpIDwgaWw7IGlpICs9IDUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmJ1ZltpaV0gKz0gX20xMjtcbiAgICAgICAgICAgICAgICAgICAgdmJ1ZltpaSArIDFdICs9IF9tMTM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChuZWVkQmF0Y2gpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpaSA9IF92Zk9mZnNldCwgaWwgPSBfdmZPZmZzZXQgKyBzZWdWRkNvdW50OyBpaSA8IGlsOyBpaSArPSA1KSB7XG4gICAgICAgICAgICAgICAgICAgIF94ID0gdmJ1ZltpaV07XG4gICAgICAgICAgICAgICAgICAgIF95ID0gdmJ1ZltpaSArIDFdO1xuICAgICAgICAgICAgICAgICAgICB2YnVmW2lpXSA9IF94ICogX20wMCArIF95ICogX20wNCArIF9tMTI7XG4gICAgICAgICAgICAgICAgICAgIHZidWZbaWkgKyAxXSA9IF94ICogX20wMSArIF95ICogX20wNSArIF9tMTM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoICEoX2hhbmRsZVZhbCAmIE5FRURfQ09MT1IpICkgY29udGludWU7XG5cbiAgICAgICAgICAgIC8vIGhhbmRsZSBjb2xvclxuICAgICAgICAgICAgbGV0IGZyYW1lQ29sb3JPZmZzZXQgPSBmcmFtZVZGT2Zmc2V0IC0gc2VnVkZDb3VudDtcbiAgICAgICAgICAgIGZvciAobGV0IGlpID0gX3ZmT2Zmc2V0ICsgNCwgaWwgPSBfdmZPZmZzZXQgKyA0ICsgc2VnVkZDb3VudDsgaWkgPCBpbDsgaWkgKz0gNSwgZnJhbWVDb2xvck9mZnNldCArPSA1KSB7XG4gICAgICAgICAgICAgICAgaWYgKGZyYW1lQ29sb3JPZmZzZXQgPj0gbWF4VkZPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgbm93Q29sb3IgPSBjb2xvcnNbY29sb3JPZmZzZXQrK107XG4gICAgICAgICAgICAgICAgICAgIF9oYW5kbGVDb2xvcihub3dDb2xvciwgMS4wKTtcbiAgICAgICAgICAgICAgICAgICAgbWF4VkZPZmZzZXQgPSBub3dDb2xvci52Zk9mZnNldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdWludGJ1ZltpaV0gPSBfYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZpbGxCdWZmZXJzIChjb21wLCByZW5kZXJlcikge1xuICAgICAgICBjb21wLm5vZGUuX3JlbmRlckZsYWcgfD0gUmVuZGVyRmxvdy5GTEFHX1VQREFURV9SRU5ERVJfREFUQTtcbiAgICAgICAgXG4gICAgICAgIGxldCBhcm1hdHVyZSA9IGNvbXAuX2FybWF0dXJlO1xuICAgICAgICBpZiAoIWFybWF0dXJlKSByZXR1cm47XG5cbiAgICAgICAgLy8gSW5pdCB0ZW1wIHZhci5cbiAgICAgICAgX211c3RGbHVzaCA9IHRydWU7XG4gICAgICAgIF9wcmVtdWx0aXBsaWVkQWxwaGEgPSBjb21wLnByZW11bHRpcGxpZWRBbHBoYTtcbiAgICAgICAgX25vZGUgPSBjb21wLm5vZGU7XG4gICAgICAgIF9idWZmZXIgPSByZW5kZXJlci5fbWVzaEJ1ZmZlcjtcbiAgICAgICAgX3JlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIF9jb21wID0gY29tcDtcbiAgICAgICAgX2hhbmRsZVZhbCA9IDA7XG5cbiAgICAgICAgbGV0IG5vZGVDb2xvciA9IF9ub2RlLl9jb2xvcjtcbiAgICAgICAgX25vZGVSID0gbm9kZUNvbG9yLnIgLyAyNTU7XG4gICAgICAgIF9ub2RlRyA9IG5vZGVDb2xvci5nIC8gMjU1O1xuICAgICAgICBfbm9kZUIgPSBub2RlQ29sb3IuYiAvIDI1NTtcbiAgICAgICAgX25vZGVBID0gbm9kZUNvbG9yLmEgLyAyNTU7XG4gICAgICAgIGlmIChub2RlQ29sb3IuX3ZhbCAhPT0gMHhmZmZmZmZmZikge1xuICAgICAgICAgICAgX2hhbmRsZVZhbCB8PSBORUVEX0NPTE9SO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHdvcmxkTWF0ID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoX2NvbXAuZW5hYmxlQmF0Y2gpIHtcbiAgICAgICAgICAgIHdvcmxkTWF0ID0gX25vZGUuX3dvcmxkTWF0cml4O1xuICAgICAgICAgICAgX211c3RGbHVzaCA9IGZhbHNlO1xuICAgICAgICAgICAgX2hhbmRsZVZhbCB8PSBORUVEX0JBVENIO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbXAuaXNBbmltYXRpb25DYWNoZWQoKSkge1xuICAgICAgICAgICAgLy8gVHJhdmVyc2UgaW5wdXQgYXNzZW1ibGVyLlxuICAgICAgICAgICAgdGhpcy5jYWNoZVRyYXZlcnNlKGNvbXAuX2N1ckZyYW1lLCB3b3JsZE1hdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUcmF2ZXJzZSBhbGwgYXJtYXR1cmUuXG4gICAgICAgICAgICB0aGlzLnJlYWxUaW1lVHJhdmVyc2UoYXJtYXR1cmUsIHdvcmxkTWF0LCAxLjApO1xuXG4gICAgICAgICAgICBsZXQgZ3JhcGhpY3MgPSBjb21wLl9kZWJ1Z0RyYXc7XG4gICAgICAgICAgICBpZiAoY29tcC5kZWJ1Z0JvbmVzICYmIGdyYXBoaWNzKSB7XG4gICAgICAgICAgICAgICAgZ3JhcGhpY3MuY2xlYXIoKTtcblxuICAgICAgICAgICAgICAgIGdyYXBoaWNzLmxpbmVXaWR0aCA9IDU7XG4gICAgICAgICAgICAgICAgZ3JhcGhpY3Muc3Ryb2tlQ29sb3IgPSBfYm9uZUNvbG9yO1xuICAgICAgICAgICAgICAgIGdyYXBoaWNzLmZpbGxDb2xvciA9IF9zbG90Q29sb3I7IC8vIFJvb3QgYm9uZSBjb2xvciBpcyBzYW1lIGFzIHNsb3QgY29sb3IuXG5cbiAgICAgICAgICAgICAgICBsZXQgYm9uZXMgPSBhcm1hdHVyZS5nZXRCb25lcygpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gYm9uZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBib25lID0gIGJvbmVzW2ldO1xuICAgICAgICAgICAgICAgICAgICBsZXQgYm9uZUxlbmd0aCA9IE1hdGgubWF4KGJvbmUuYm9uZURhdGEubGVuZ3RoLCA1KTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN0YXJ0WCA9IGJvbmUuZ2xvYmFsVHJhbnNmb3JtTWF0cml4LnR4O1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3RhcnRZID0gYm9uZS5nbG9iYWxUcmFuc2Zvcm1NYXRyaXgudHk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBlbmRYID0gc3RhcnRYICsgYm9uZS5nbG9iYWxUcmFuc2Zvcm1NYXRyaXguYSAqIGJvbmVMZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGxldCBlbmRZID0gc3RhcnRZICsgYm9uZS5nbG9iYWxUcmFuc2Zvcm1NYXRyaXguYiAqIGJvbmVMZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAgICAgZ3JhcGhpY3MubW92ZVRvKHN0YXJ0WCwgc3RhcnRZKTtcbiAgICAgICAgICAgICAgICAgICAgZ3JhcGhpY3MubGluZVRvKGVuZFgsIGVuZFkpO1xuICAgICAgICAgICAgICAgICAgICBncmFwaGljcy5zdHJva2UoKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBCb25lIG9yaWdpbnMuXG4gICAgICAgICAgICAgICAgICAgIGdyYXBoaWNzLmNpcmNsZShzdGFydFgsIHN0YXJ0WSwgTWF0aC5QSSAqIDIpO1xuICAgICAgICAgICAgICAgICAgICBncmFwaGljcy5maWxsKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBncmFwaGljcy5maWxsQ29sb3IgPSBfb3JpZ2luQ29sb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIHN5bmMgYXR0YWNoZWQgbm9kZSBtYXRyaXhcbiAgICAgICAgcmVuZGVyZXIud29ybGRNYXREaXJ0eSsrO1xuICAgICAgICBjb21wLmF0dGFjaFV0aWwuX3N5bmNBdHRhY2hlZE5vZGUoKTtcblxuICAgICAgICAvLyBDbGVhciB0ZW1wIHZhci5cbiAgICAgICAgX25vZGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIF9idWZmZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIF9yZW5kZXJlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgX2NvbXAgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgcG9zdEZpbGxCdWZmZXJzIChjb21wLCByZW5kZXJlcikge1xuICAgICAgICByZW5kZXJlci53b3JsZE1hdERpcnR5LS07XG4gICAgfVxufVxuXG5Bc3NlbWJsZXIucmVnaXN0ZXIoQXJtYXR1cmUsIEFybWF0dXJlQXNzZW1ibGVyKTtcbiJdfQ==