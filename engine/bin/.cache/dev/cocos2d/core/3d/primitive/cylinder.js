
                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'engine-dev/cocos2d/core/3d/primitive/cylinder.js';
                    var __require = nodeEnv ? function (request) {
                        return require(request);
                    } : function (request) {
                        return __quick_compile_engine__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_engine__.registerModule(__filename, module);}'use strict';

exports.__esModule = true;
exports["default"] = _default;

var _vec = _interopRequireDefault(require("../../value-types/vec3"));

var _vertexData = _interopRequireDefault(require("./vertex-data"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var temp1 = new _vec["default"]();
var temp2 = new _vec["default"]();
/**
 * @param {Number} radiusTop
 * @param {Number} radiusBottom
 * @param {Number} height
 * @param {Object} opts
 * @param {Number} opts.radialSegments
 * @param {Number} opts.heightSegments
 * @param {Boolean} opts.capped
 * @param {Number} opts.arc
 */

function _default(radiusTop, radiusBottom, height, opts) {
  if (radiusTop === void 0) {
    radiusTop = 0.5;
  }

  if (radiusBottom === void 0) {
    radiusBottom = 0.5;
  }

  if (height === void 0) {
    height = 2;
  }

  if (opts === void 0) {
    opts = {
      radialSegments: 32,
      heightSegments: 1,
      capped: true,
      arc: 2.0 * Math.PI
    };
  }

  var halfHeight = height * 0.5;
  var radialSegments = opts.radialSegments;
  var heightSegments = opts.heightSegments;
  var capped = opts.capped;
  var arc = opts.arc;
  var cntCap = 0;

  if (!capped) {
    if (radiusTop > 0) {
      cntCap++;
    }

    if (radiusBottom > 0) {
      cntCap++;
    }
  } // calculate vertex count


  var vertCount = (radialSegments + 1) * (heightSegments + 1);

  if (capped) {
    vertCount += (radialSegments + 1) * cntCap + radialSegments * cntCap;
  } // calculate index count


  var indexCount = radialSegments * heightSegments * 2 * 3;

  if (capped) {
    indexCount += radialSegments * cntCap * 3;
  }

  var indices = new Array(indexCount);
  var positions = new Array(vertCount * 3);
  var normals = new Array(vertCount * 3);
  var uvs = new Array(vertCount * 2);
  var maxRadius = Math.max(radiusTop, radiusBottom);
  var minPos = new _vec["default"](-maxRadius, -halfHeight, -maxRadius);
  var maxPos = new _vec["default"](maxRadius, halfHeight, maxRadius);
  var boundingRadius = Math.sqrt(maxRadius * maxRadius + halfHeight * halfHeight);
  var index = 0;
  var indexOffset = 0;
  generateTorso();

  if (capped) {
    if (radiusBottom > 0) {
      generateCap(false);
    }

    if (radiusTop > 0) {
      generateCap(true);
    }
  }

  return new _vertexData["default"](positions, normals, uvs, indices, minPos, maxPos, boundingRadius); // =======================
  // internal fucntions
  // =======================

  function generateTorso() {
    var indexArray = []; // this will be used to calculate the normal

    var r = radiusTop - radiusBottom;
    var slope = r * r / height * Math.sign(r); // generate positions, normals and uvs

    for (var y = 0; y <= heightSegments; y++) {
      var indexRow = [];
      var v = y / heightSegments; // calculate the radius of the current row

      var radius = v * r + radiusBottom;

      for (var x = 0; x <= radialSegments; ++x) {
        var u = x / radialSegments;
        var theta = u * arc;
        var sinTheta = Math.sin(theta);
        var cosTheta = Math.cos(theta); // vertex

        positions[3 * index] = radius * sinTheta;
        positions[3 * index + 1] = v * height - halfHeight;
        positions[3 * index + 2] = radius * cosTheta; // normal

        _vec["default"].normalize(temp1, _vec["default"].set(temp2, sinTheta, -slope, cosTheta));

        normals[3 * index] = temp1.x;
        normals[3 * index + 1] = temp1.y;
        normals[3 * index + 2] = temp1.z; // uv

        uvs[2 * index] = (1 - u) * 2 % 1;
        uvs[2 * index + 1] = v; // save index of vertex in respective row

        indexRow.push(index); // increase index

        ++index;
      } // now save positions of the row in our index array


      indexArray.push(indexRow);
    } // generate indices


    for (var _y = 0; _y < heightSegments; ++_y) {
      for (var _x = 0; _x < radialSegments; ++_x) {
        // we use the index array to access the correct indices
        var i1 = indexArray[_y][_x];
        var i2 = indexArray[_y + 1][_x];
        var i3 = indexArray[_y + 1][_x + 1];
        var i4 = indexArray[_y][_x + 1]; // face one

        indices[indexOffset] = i1;
        ++indexOffset;
        indices[indexOffset] = i4;
        ++indexOffset;
        indices[indexOffset] = i2;
        ++indexOffset; // face two

        indices[indexOffset] = i4;
        ++indexOffset;
        indices[indexOffset] = i3;
        ++indexOffset;
        indices[indexOffset] = i2;
        ++indexOffset;
      }
    }
  }

  function generateCap(top) {
    var centerIndexStart, centerIndexEnd;
    var radius = top ? radiusTop : radiusBottom;
    var sign = top ? 1 : -1; // save the index of the first center vertex

    centerIndexStart = index; // first we generate the center vertex data of the cap.
    // because the geometry needs one set of uvs per face,
    // we must generate a center vertex per face/segment

    for (var x = 1; x <= radialSegments; ++x) {
      // vertex
      positions[3 * index] = 0;
      positions[3 * index + 1] = halfHeight * sign;
      positions[3 * index + 2] = 0; // normal

      normals[3 * index] = 0;
      normals[3 * index + 1] = sign;
      normals[3 * index + 2] = 0; // uv

      uvs[2 * index] = 0.5;
      uvs[2 * index + 1] = 0.5; // increase index

      ++index;
    } // save the index of the last center vertex


    centerIndexEnd = index; // now we generate the surrounding positions, normals and uvs

    for (var _x2 = 0; _x2 <= radialSegments; ++_x2) {
      var u = _x2 / radialSegments;
      var theta = u * arc;
      var cosTheta = Math.cos(theta);
      var sinTheta = Math.sin(theta); // vertex

      positions[3 * index] = radius * sinTheta;
      positions[3 * index + 1] = halfHeight * sign;
      positions[3 * index + 2] = radius * cosTheta; // normal

      normals[3 * index] = 0;
      normals[3 * index + 1] = sign;
      normals[3 * index + 2] = 0; // uv

      uvs[2 * index] = 0.5 - sinTheta * 0.5 * sign;
      uvs[2 * index + 1] = 0.5 + cosTheta * 0.5; // increase index

      ++index;
    } // generate indices


    for (var _x3 = 0; _x3 < radialSegments; ++_x3) {
      var c = centerIndexStart + _x3;
      var i = centerIndexEnd + _x3;

      if (top) {
        // face top
        indices[indexOffset] = i + 1;
        ++indexOffset;
        indices[indexOffset] = c;
        ++indexOffset;
        indices[indexOffset] = i;
        ++indexOffset;
      } else {
        // face bottom
        indices[indexOffset] = c;
        ++indexOffset;
        indices[indexOffset] = i + 1;
        ++indexOffset;
        indices[indexOffset] = i;
        ++indexOffset;
      }
    }
  }
}

module.exports = exports["default"];
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_engine__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImN5bGluZGVyLnRzIl0sIm5hbWVzIjpbInRlbXAxIiwiVmVjMyIsInRlbXAyIiwicmFkaXVzVG9wIiwicmFkaXVzQm90dG9tIiwiaGVpZ2h0Iiwib3B0cyIsInJhZGlhbFNlZ21lbnRzIiwiaGVpZ2h0U2VnbWVudHMiLCJjYXBwZWQiLCJhcmMiLCJNYXRoIiwiUEkiLCJoYWxmSGVpZ2h0IiwiY250Q2FwIiwidmVydENvdW50IiwiaW5kZXhDb3VudCIsImluZGljZXMiLCJBcnJheSIsInBvc2l0aW9ucyIsIm5vcm1hbHMiLCJ1dnMiLCJtYXhSYWRpdXMiLCJtYXgiLCJtaW5Qb3MiLCJtYXhQb3MiLCJib3VuZGluZ1JhZGl1cyIsInNxcnQiLCJpbmRleCIsImluZGV4T2Zmc2V0IiwiZ2VuZXJhdGVUb3JzbyIsImdlbmVyYXRlQ2FwIiwiVmVydGV4RGF0YSIsImluZGV4QXJyYXkiLCJyIiwic2xvcGUiLCJzaWduIiwieSIsImluZGV4Um93IiwidiIsInJhZGl1cyIsIngiLCJ1IiwidGhldGEiLCJzaW5UaGV0YSIsInNpbiIsImNvc1RoZXRhIiwiY29zIiwibm9ybWFsaXplIiwic2V0IiwieiIsInB1c2giLCJpMSIsImkyIiwiaTMiLCJpNCIsInRvcCIsImNlbnRlckluZGV4U3RhcnQiLCJjZW50ZXJJbmRleEVuZCIsImMiLCJpIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBOzs7OztBQUVBOztBQUNBOzs7O0FBRUEsSUFBSUEsS0FBSyxHQUFHLElBQUlDLGVBQUosRUFBWjtBQUNBLElBQUlDLEtBQUssR0FBRyxJQUFJRCxlQUFKLEVBQVo7QUFFQTs7Ozs7Ozs7Ozs7QUFVZSxrQkFBVUUsU0FBVixFQUEyQkMsWUFBM0IsRUFBK0NDLE1BQS9DLEVBQTJEQyxJQUEzRCxFQUE2STtBQUFBLE1BQW5JSCxTQUFtSTtBQUFuSUEsSUFBQUEsU0FBbUksR0FBdkgsR0FBdUg7QUFBQTs7QUFBQSxNQUFsSEMsWUFBa0g7QUFBbEhBLElBQUFBLFlBQWtILEdBQW5HLEdB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QXlDO0FBQ3ZDLFVBQUlrQixDQUFDLEdBQUdGLGdCQUFnQixHQUFHaEIsR0FBM0I7QUFDQSxVQUFJbUIsQ0FBQyxHQUFHRixjQUFjLEdBQUdqQixHQUF6Qjs7QUFFQSxVQUFJZSxHQUFKLEVBQVM7QUFDUDtBQUNBdkMsUUFBQUEsT0FBTyxDQUFDWSxXQUFELENBQVAsR0FBdUIrQixDQUFDLEdBQUcsQ0FBM0I7QUFBOEIsVUFBRS9CLFdBQUY7QUFDOUJaLFFBQUFBLE9BQU8sQ0FBQ1ksV0FBRCxDQUFQLEdBQXVCOEIsQ0FBdkI7QUFBMEIsVUFBRTlCLFdBQUY7QUFDMUJaLFFBQUFBLE9BQU8sQ0FBQ1ksV0FBRCxDQUFQLEdBQXVCK0IsQ0FBdkI7QUFBMEIsVUFBRS9CLFdBQUY7QUFDM0IsT0FMRCxNQUtPO0FBQ0w7QUFDQVosUUFBQUEsT0FBTyxDQUFDWSxXQUFELENBQVAsR0FBdUI4QixDQUF2QjtBQUEwQixVQUFFOUIsV0FBRjtBQUMxQlosUUFBQUEsT0FBTyxDQUFDWSxXQUFELENBQVAsR0FBdUIrQixDQUFDLEdBQUcsQ0FBM0I7QUFBOEIsVUFBRS9CLFdBQUY7QUFDOUJaLFFBQUFBLE9BQU8sQ0FBQ1ksV0FBRCxDQUFQLEdBQXVCK0IsQ0FBdkI7QUFBMEIsVUFBRS9CLFdBQUY7QUFDM0I7QUFDRjtBQUNGO0FBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBWZWMzIGZyb20gJy4uLy4uL3ZhbHVlLXR5cGVzL3ZlYzMnO1xuaW1wb3J0IFZlcnRleERhdGEgZnJvbSAnLi92ZXJ0ZXgtZGF0YSc7XG5cbmxldCB0ZW1wMSA9IG5ldyBWZWMzKCk7XG5sZXQgdGVtcDIgPSBuZXcgVmVjMygpO1xuXG4vKipcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNUb3BcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNCb3R0b21cbiAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0cy5yYWRpYWxTZWdtZW50c1xuICogQHBhcmFtIHtOdW1iZXJ9IG9wdHMuaGVpZ2h0U2VnbWVudHNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0cy5jYXBwZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRzLmFyY1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAocmFkaXVzVG9wID0gMC41LCByYWRpdXNCb3R0b20gPSAwLjUsIGhlaWdodCA9IDIsIG9wdHMgPSB7cmFkaWFsU2VnbWVudHM6IDMyLCBoZWlnaHRTZWdtZW50czogMSwgY2FwcGVkOiB0cnVlLCBhcmM6IDIuMCAqIE1hdGguUEl9KSB7XG4gIGxldCBoYWxmSGVpZ2h0ID0gaGVpZ2h0ICogMC41O1xuICBsZXQgcmFkaWFsU2VnbWVudHMgPSBvcHRzLnJhZGlhbFNlZ21lbnRzO1xuICBsZXQgaGVpZ2h0U2VnbWVudHMgPSBvcHRzLmhlaWdodFNlZ21lbnRzO1xuICBsZXQgY2FwcGVkID0gb3B0cy5jYXBwZWQ7XG4gIGxldCBhcmMgPSBvcHRzLmFyYztcblxuICBsZXQgY250Q2FwID0gMDtcbiAgaWYgKCFjYXBwZWQpIHtcbiAgICBpZiAocmFkaXVzVG9wID4gMCkge1xuICAgICAgY250Q2FwKys7XG4gICAgfVxuXG4gICAgaWYgKHJhZGl1c0JvdHRvbSA+IDApIHtcbiAgICAgIGNudENhcCsrO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNhbGN1bGF0ZSB2ZXJ0ZXggY291bnRcbiAgbGV0IHZlcnRDb3VudCA9IChyYWRpYWxTZWdtZW50cyArIDEpICogKGhlaWdodFNlZ21lbnRzICsgMSk7XG4gIGlmIChjYXBwZWQpIHtcbiAgICB2ZXJ0Q291bnQgKz0gKChyYWRpYWxTZWdtZW50cyArIDEpICogY250Q2FwKSArIChyYWRpYWxTZWdtZW50cyAqIGNudENhcCk7XG4gIH1cblxuICAvLyBjYWxjdWxhdGUgaW5kZXggY291bnRcbiAgbGV0IGluZGV4Q291bnQgPSByYWRpYWxTZWdtZW50cyAqIGhlaWdodFNlZ21lbnRzICogMiAqIDM7XG4gIGlmIChjYXBwZWQpIHtcbiAgICBpbmRleENvdW50ICs9IHJhZGlhbFNlZ21lbnRzICogY250Q2FwICogMztcbiAgfVxuXG4gIGxldCBpbmRpY2VzID0gbmV3IEFycmF5KGluZGV4Q291bnQpO1xuICBsZXQgcG9zaXRpb25zID0gbmV3IEFycmF5KHZlcnRDb3VudCAqIDMpO1xuICBsZXQgbm9ybWFscyA9IG5ldyBBcnJheSh2ZXJ0Q291bnQgKiAzKTtcbiAgbGV0IHV2cyA9IG5ldyBBcnJheSh2ZXJ0Q291bnQgKiAyKTtcbiAgbGV0IG1heFJhZGl1cyA9IE1hdGgubWF4KHJhZGl1c1RvcCwgcmFkaXVzQm90dG9tKTtcbiAgbGV0IG1pblBvcyA9IG5ldyBWZWMzKC1tYXhSYWRpdXMsIC1oYWxmSGVpZ2h0LCAtbWF4UmFkaXVzKTtcbiAgbGV0IG1heFBvcyA9IG5ldyBWZWMzKG1heFJhZGl1cywgaGFsZkhlaWdodCwgbWF4UmFkaXVzKTtcbiAgbGV0IGJvdW5kaW5nUmFkaXVzID0gTWF0aC5zcXJ0KG1heFJhZGl1cyAqIG1heFJhZGl1cyArIGhhbGZIZWlnaHQgKiBoYWxmSGVpZ2h0KTtcblxuICBsZXQgaW5kZXggPSAwO1xuICBsZXQgaW5kZXhPZmZzZXQgPSAwO1xuXG4gIGdlbmVyYXRlVG9yc28oKTtcblxuICBpZiAoY2FwcGVkKSB7XG4gICAgaWYgKHJhZGl1c0JvdHRvbSA+IDApIHtcbiAgICAgIGdlbmVyYXRlQ2FwKGZhbHNlKTtcbiAgICB9XG5cbiAgICBpZiAocmFkaXVzVG9wID4gMCkge1xuICAgICAgZ2VuZXJhdGVDYXAodHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBWZXJ0ZXhEYXRhKFxuICAgIHBvc2l0aW9ucyxcbiAgICBub3JtYWxzLFxuICAgIHV2cyxcbiAgICBpbmRpY2VzLFxuICAgIG1pblBvcyxcbiAgICBtYXhQb3MsXG4gICAgYm91bmRpbmdSYWRpdXNcbiAgKTtcblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBpbnRlcm5hbCBmdWNudGlvbnNcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT1cblxuICBmdW5jdGlvbiBnZW5lcmF0ZVRvcnNvKCkge1xuICAgIGxldCBpbmRleEFycmF5OiBudW1iZXJbXVtdID0gW107XG5cbiAgICAvLyB0aGlzIHdpbGwgYmUgdXNlZCB0byBjYWxjdWxhdGUgdGhlIG5vcm1hbFxuICAgIGxldCByID0gcmFkaXVzVG9wIC0gcmFkaXVzQm90dG9tO1xuICAgIGxldCBzbG9wZSA9IHIgKiByIC8gaGVpZ2h0ICogTWF0aC5zaWduKHIpO1xuXG4gICAgLy8gZ2VuZXJhdGUgcG9zaXRpb25zLCBub3JtYWxzIGFuZCB1dnNcbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8PSBoZWlnaHRTZWdtZW50czsgeSsrKSB7XG4gICAgICBsZXQgaW5kZXhSb3c6IG51bWJlcltdID0gW107XG4gICAgICBsZXQgdiA9IHkgLyBoZWlnaHRTZWdtZW50cztcblxuICAgICAgLy8gY2FsY3VsYXRlIHRoZSByYWRpdXMgb2YgdGhlIGN1cnJlbnQgcm93XG4gICAgICBsZXQgcmFkaXVzID0gdiAqIHIgKyByYWRpdXNCb3R0b207XG5cbiAgICAgIGZvciAobGV0IHggPSAwOyB4IDw9IHJhZGlhbFNlZ21lbnRzOyArK3gpIHtcbiAgICAgICAgbGV0IHUgPSB4IC8gcmFkaWFsU2VnbWVudHM7XG4gICAgICAgIGxldCB0aGV0YSA9IHUgKiBhcmM7XG5cbiAgICAgICAgbGV0IHNpblRoZXRhID0gTWF0aC5zaW4odGhldGEpO1xuICAgICAgICBsZXQgY29zVGhldGEgPSBNYXRoLmNvcyh0aGV0YSk7XG5cbiAgICAgICAgLy8gdmVydGV4XG4gICAgICAgIHBvc2l0aW9uc1szICogaW5kZXhdID0gcmFkaXVzICogc2luVGhldGE7XG4gICAgICAgIHBvc2l0aW9uc1szICogaW5kZXggKyAxXSA9IHYgKiBoZWlnaHQgLSBoYWxmSGVpZ2h0O1xuICAgICAgICBwb3NpdGlvbnNbMyAqIGluZGV4ICsgMl0gPSByYWRpdXMgKiBjb3NUaGV0YTtcblxuICAgICAgICAvLyBub3JtYWxcbiAgICAgICAgVmVjMy5ub3JtYWxpemUodGVtcDEsIFZlYzMuc2V0KHRlbXAyLCBzaW5UaGV0YSwgLXNsb3BlLCBjb3NUaGV0YSkpO1xuICAgICAgICBub3JtYWxzWzMgKiBpbmRleF0gPSB0ZW1wMS54O1xuICAgICAgICBub3JtYWxzWzMgKiBpbmRleCArIDFdID0gdGVtcDEueTtcbiAgICAgICAgbm9ybWFsc1szICogaW5kZXggKyAyXSA9IHRlbXAxLno7XG5cbiAgICAgICAgLy8gdXZcbiAgICAgICAgdXZzWzIgKiBpbmRleF0gPSAoMSAtIHUpICogMiAlIDE7XG4gICAgICAgIHV2c1syICogaW5kZXggKyAxXSA9IHY7XG5cbiAgICAgICAgLy8gc2F2ZSBpbmRleCBvZiB2ZXJ0ZXggaW4gcmVzcGVjdGl2ZSByb3dcbiAgICAgICAgaW5kZXhSb3cucHVzaChpbmRleCk7XG5cbiAgICAgICAgLy8gaW5jcmVhc2UgaW5kZXhcbiAgICAgICAgKytpbmRleDtcbiAgICAgIH1cblxuICAgICAgLy8gbm93IHNhdmUgcG9zaXRpb25zIG9mIHRoZSByb3cgaW4gb3VyIGluZGV4IGFycmF5XG4gICAgICBpbmRleEFycmF5LnB1c2goaW5kZXhSb3cpO1xuICAgIH1cblxuICAgIC8vIGdlbmVyYXRlIGluZGljZXNcbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodFNlZ21lbnRzOyArK3kpIHtcbiAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgcmFkaWFsU2VnbWVudHM7ICsreCkge1xuICAgICAgICAvLyB3ZSB1c2UgdGhlIGluZGV4IGFycmF5IHRvIGFjY2VzcyB0aGUgY29ycmVjdCBpbmRpY2VzXG4gICAgICAgIGxldCBpMSA9IGluZGV4QXJyYXlbeV1beF07XG4gICAgICAgIGxldCBpMiA9IGluZGV4QXJyYXlbeSArIDFdW3hdO1xuICAgICAgICBsZXQgaTMgPSBpbmRleEFycmF5W3kgKyAxXVt4ICsgMV07XG4gICAgICAgIGxldCBpNCA9IGluZGV4QXJyYXlbeV1beCArIDFdO1xuXG4gICAgICAgIC8vIGZhY2Ugb25lXG4gICAgICAgIGluZGljZXNbaW5kZXhPZmZzZXRdID0gaTE7ICsraW5kZXhPZmZzZXQ7XG4gICAgICAgIGluZGljZXNbaW5kZXhPZmZzZXRdID0gaTQ7ICsraW5kZXhPZmZzZXQ7XG4gICAgICAgIGluZGljZXNbaW5kZXhPZmZzZXRdID0gaTI7ICsraW5kZXhPZmZzZXQ7XG5cbiAgICAgICAgLy8gZmFjZSB0d29cbiAgICAgICAgaW5kaWNlc1tpbmRleE9mZnNldF0gPSBpNDsgKytpbmRleE9mZnNldDtcbiAgICAgICAgaW5kaWNlc1tpbmRleE9mZnNldF0gPSBpMzsgKytpbmRleE9mZnNldDtcbiAgICAgICAgaW5kaWNlc1tpbmRleE9mZnNldF0gPSBpMjsgKytpbmRleE9mZnNldDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZW5lcmF0ZUNhcCh0b3ApIHtcbiAgICBsZXQgY2VudGVySW5kZXhTdGFydCwgY2VudGVySW5kZXhFbmQ7XG5cbiAgICBsZXQgcmFkaXVzID0gdG9wID8gcmFkaXVzVG9wIDogcmFkaXVzQm90dG9tO1xuICAgIGxldCBzaWduID0gdG9wID8gMSA6IC0gMTtcblxuICAgIC8vIHNhdmUgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBjZW50ZXIgdmVydGV4XG4gICAgY2VudGVySW5kZXhTdGFydCA9IGluZGV4O1xuXG4gICAgLy8gZmlyc3Qgd2UgZ2VuZXJhdGUgdGhlIGNlbnRlciB2ZXJ0ZXggZGF0YSBvZiB0aGUgY2FwLlxuICAgIC8vIGJlY2F1c2UgdGhlIGdlb21ldHJ5IG5lZWRzIG9uZSBzZXQgb2YgdXZzIHBlciBmYWNlLFxuICAgIC8vIHdlIG11c3QgZ2VuZXJhdGUgYSBjZW50ZXIgdmVydGV4IHBlciBmYWNlL3NlZ21lbnRcblxuICAgIGZvciAobGV0IHggPSAxOyB4IDw9IHJhZGlhbFNlZ21lbnRzOyArK3gpIHtcbiAgICAgIC8vIHZlcnRleFxuICAgICAgcG9zaXRpb25zWzMgKiBpbmRleF0gPSAwO1xuICAgICAgcG9zaXRpb25zWzMgKiBpbmRleCArIDFdID0gaGFsZkhlaWdodCAqIHNpZ247XG4gICAgICBwb3NpdGlvbnNbMyAqIGluZGV4ICsgMl0gPSAwO1xuXG4gICAgICAvLyBub3JtYWxcbiAgICAgIG5vcm1hbHNbMyAqIGluZGV4XSA9IDA7XG4gICAgICBub3JtYWxzWzMgKiBpbmRleCArIDFdID0gc2lnbjtcbiAgICAgIG5vcm1hbHNbMyAqIGluZGV4ICsgMl0gPSAwO1xuXG4gICAgICAvLyB1dlxuICAgICAgdXZzWzIgKiBpbmRleF0gPSAwLjU7XG4gICAgICB1dnNbMiAqIGluZGV4ICsgMV0gPSAwLjU7XG5cbiAgICAgIC8vIGluY3JlYXNlIGluZGV4XG4gICAgICArK2luZGV4O1xuICAgIH1cblxuICAgIC8vIHNhdmUgdGhlIGluZGV4IG9mIHRoZSBsYXN0IGNlbnRlciB2ZXJ0ZXhcbiAgICBjZW50ZXJJbmRleEVuZCA9IGluZGV4O1xuXG4gICAgLy8gbm93IHdlIGdlbmVyYXRlIHRoZSBzdXJyb3VuZGluZyBwb3NpdGlvbnMsIG5vcm1hbHMgYW5kIHV2c1xuXG4gICAgZm9yIChsZXQgeCA9IDA7IHggPD0gcmFkaWFsU2VnbWVudHM7ICsreCkge1xuICAgICAgbGV0IHUgPSB4IC8gcmFkaWFsU2VnbWVudHM7XG4gICAgICBsZXQgdGhldGEgPSB1ICogYXJjO1xuXG4gICAgICBsZXQgY29zVGhldGEgPSBNYXRoLmNvcyh0aGV0YSk7XG4gICAgICBsZXQgc2luVGhldGEgPSBNYXRoLnNpbih0aGV0YSk7XG5cbiAgICAgIC8vIHZlcnRleFxuICAgICAgcG9zaXRpb25zWzMgKiBpbmRleF0gPSByYWRpdXMgKiBzaW5UaGV0YTtcbiAgICAgIHBvc2l0aW9uc1szICogaW5kZXggKyAxXSA9IGhhbGZIZWlnaHQgKiBzaWduO1xuICAgICAgcG9zaXRpb25zWzMgKiBpbmRleCArIDJdID0gcmFkaXVzICogY29zVGhldGE7XG5cbiAgICAgIC8vIG5vcm1hbFxuICAgICAgbm9ybWFsc1szICogaW5kZXhdID0gMDtcbiAgICAgIG5vcm1hbHNbMyAqIGluZGV4ICsgMV0gPSBzaWduO1xuICAgICAgbm9ybWFsc1szICogaW5kZXggKyAyXSA9IDA7XG5cbiAgICAgIC8vIHV2XG4gICAgICB1dnNbMiAqIGluZGV4XSA9IDAuNSAtIChzaW5UaGV0YSAqIDAuNSAqIHNpZ24pO1xuICAgICAgdXZzWzIgKiBpbmRleCArIDFdID0gMC41ICsgKGNvc1RoZXRhICogMC41KTtcblxuICAgICAgLy8gaW5jcmVhc2UgaW5kZXhcbiAgICAgICsraW5kZXg7XG4gICAgfVxuXG4gICAgLy8gZ2VuZXJhdGUgaW5kaWNlc1xuXG4gICAgZm9yIChsZXQgeCA9IDA7IHggPCByYWRpYWxTZWdtZW50czsgKyt4KSB7XG4gICAgICBsZXQgYyA9IGNlbnRlckluZGV4U3RhcnQgKyB4O1xuICAgICAgbGV0IGkgPSBjZW50ZXJJbmRleEVuZCArIHg7XG5cbiAgICAgIGlmICh0b3ApIHtcbiAgICAgICAgLy8gZmFjZSB0b3BcbiAgICAgICAgaW5kaWNlc1tpbmRleE9mZnNldF0gPSBpICsgMTsgKytpbmRleE9mZnNldDtcbiAgICAgICAgaW5kaWNlc1tpbmRleE9mZnNldF0gPSBjOyArK2luZGV4T2Zmc2V0O1xuICAgICAgICBpbmRpY2VzW2luZGV4T2Zmc2V0XSA9IGk7ICsraW5kZXhPZmZzZXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBmYWNlIGJvdHRvbVxuICAgICAgICBpbmRpY2VzW2luZGV4T2Zmc2V0XSA9IGM7ICsraW5kZXhPZmZzZXQ7XG4gICAgICAgIGluZGljZXNbaW5kZXhPZmZzZXRdID0gaSArIDE7ICsraW5kZXhPZmZzZXQ7XG4gICAgICAgIGluZGljZXNbaW5kZXhPZmZzZXRdID0gaTsgKytpbmRleE9mZnNldDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiJdfQ==