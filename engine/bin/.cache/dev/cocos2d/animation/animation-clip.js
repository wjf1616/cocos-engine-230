
                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'engine-dev/cocos2d/animation/animation-clip.js';
                    var __require = nodeEnv ? function (request) {
                        return require(request);
                    } : function (request) {
                        return __quick_compile_engine__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_engine__.registerModule(__filename, module);}"use strict";

/****************************************************************************
 Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.

 https://www.cocos.com/

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated engine source code (the "Software"), a limited,
 worldwide, royalty-free, non-assignable, revocable and non-exclusive license
 to use Cocos Creator solely to develop games on your target platforms. You shall
 not use Cocos Creator software for developing other software or tools that's
 used for developing games. You are not granted to publish, distribute,
 sublicense, and/or sell copies of Cocos Creator.

 The software or tools in this License Agreement are licensed, not sold.
 Xiamen Yaji Software Co., Ltd. reserves all rights not expressly granted to you.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/
var WrapMode = require('./types').WrapMode;

var _require = require('./animation-curves'),
    DynamicAnimCurve = _require.DynamicAnimCurve,
    quickFindIndex = _require.quickFindIndex;

var sampleMotionPaths = require('./motion-path-helper').sampleMotionPaths;

var binarySearch = require('../core/utils/binary-search').binarySearchEpsilon;
/**
 * !#en Class for animation data handling.
 * !#zh 动画剪辑，用于存储动画数据。
 * @class AnimationClip
 * @extends Asset
 */


var AnimationClip = cc.Class({
  name: 'cc.AnimationClip',
  "extends": cc.Asset,
  properties: {
    _duration: {
      "default": 0,
      type: cc.Float
    },

    /**
     * !#en Duration of this animation.
     * !#zh 动画的持续时间。
     * @property duration
     * @type {Number}
     */
    duration: {
      get: function get() {
        return this._duration;
      }
    },

    /**
     * !#en FrameRate of this animation.
     * !#zh 动画的帧速率。
     * @property sample
     * @type {Number}
     */
    sample: {
      "default": 60
    },

    /**
     * !#en Speed of this animation.
     * !#zh 动画的播放速度。
     * @property speed
     * @type {Number}
     */
    speed: {
      "default": 1
    },

    /**
     * !#en WrapMode of this animation.
     * !#zh 动画的循环模式。
     * @property wrapMode
     * @type {WrapMode}
     */
    wrapMode: {
      "default": WrapMode.Normal
    },

    /**
     * !#en Curve data.
     * !#zh 曲线数据。
     * @property curveData
     * @type {Object}
     * @example {@link cocos2d/core/animation-clip/curve-data.js}
     */
    curveData: {
      "default": {},
      visible: false
    },

    /**
     * !#en Event data.
     * !#zh 事件数据。
     * @property events
     * @type {Object[]}
     * @example {@link cocos2d/core/animation-clip/event-data.js}
     * @typescript events: {frame: number, func: string, params: string[]}[]
     */
    events: {
      "default": [],
      visible: false
    }
  },
  statics: {
    /**
     * !#en Crate clip with a set of sprite frames
     * !#zh 使用一组序列帧图片来创建动画剪辑
     * @method createWithSpriteFrames
     * @param {[SpriteFrame]} spriteFrames
     * @param {Number} sample
     * @return {AnimationClip}
     * @static
     * @example
     *
     * var clip = cc.AnimationClip.createWithSpriteFrames(spriteFrames, 10);
     *
     */
    createWithSpriteFrames: function createWithSpriteFrames(spriteFrames, sample) {
      if (!Array.isArray(spriteFrames)) {
        cc.errorID(3905);
        return null;
      }

      var clip = new AnimationClip();
      clip.sample = sample || clip.sample;
      clip._duration = spriteFrames.length / clip.sample;
      var frames = [];
      var step = 1 / clip.sample;

      for (var i = 0, l = spriteFrames.length; i < l; i++) {
        frames[i] = {
          frame: i * step,
          value: spriteFrames[i]
        };
      }

      clip.curveData = {
        comps: {
          // component
          'cc.Sprite': {
            // component properties
            'spriteFrame': frames
          }
        }
      };
      return clip;
    }
  },
  onLoad: function onLoad() {
    this._duration = Number.parseFloat(this.duration);
    this.speed = Number.parseFloat(this.speed);
    this.wrapMode = Number.parseInt(this.wrapMode);
    this.frameRate = Number.parseFloat(this.sample);
  },
  createPropCurve: function createPropCurve(target, propPath, keyframes) {
    var motionPaths = [];
    var isMotionPathProp = target instanceof cc.Node && propPath === 'position';
    var curve = new DynamicAnimCurve(); // 缓存目标对象，所以 Component 必须一开始都创建好并且不能运行时动态替换……

    curve.target = target;
    curve.prop = propPath; // for each keyframes

    for (var i = 0, l = keyframes.length; i < l; i++) {
      var keyframe = keyframes[i];
      var ratio = keyframe.frame / this.duration;
      curve.ratios.push(ratio);

      if (isMotionPathProp) {
        motionPaths.push(keyframe.motionPath);
      }

      var curveValue = keyframe.value;
      curve.values.push(curveValue);
      var curveTypes = keyframe.curve;

      if (curveTypes) {
        if (typeof curveTypes === 'string') {
          curve.types.push(curveTypes);
          continue;
        } else if (Array.isArray(curveTypes)) {
          if (curveTypes[0] === curveTypes[1] && curveTypes[2] === curveTypes[3]) {
            curve.types.push(DynamicAnimCurve.Linear);
          } else {
            curve.types.push(DynamicAnimCurve.Bezier(curveTypes));
          }

          continue;
        }
      }

      curve.types.push(DynamicAnimCurve.Linear);
    }

    if (isMotionPathProp) {
      sampleMotionPaths(motionPaths, curve, this.duration, this.sample, target);
    } // if every piece of ratios are the same, we can use the quick function to find frame index.


    var ratios = curve.ratios;
    var currRatioDif, lastRatioDif;
    var canOptimize = true;
    var EPSILON = 1e-6;

    for (var _i = 1, _l = ratios.length; _i < _l; _i++) {
      currRatioDif = ratios[_i] - ratios[_i - 1];

      if (_i === 1) {
        lastRatioDif = currRatioDif;
      } else if (Math.abs(currRatioDif - lastRatioDif) > EPSILON) {
        canOptimize = false;
        break;
      }
    }

    curve._findFrameIndex = canOptimize ? quickFindIndex : binarySearch; // find the lerp function

    var firstValue = curve.values[0];

    if (firstValue !== undefined && firstValue !== null && !curve._lerp) {
      if (typeof firstValue === 'number') {
        curve._lerp = DynamicAnimCurve.prototype._lerpNumber;
      } else if (firstValue instanceof cc.Quat) {
        curve._lerp = DynamicAnimCurve.prototype._lerpQuat;
      } else if (firstValue instanceof cc.Vec2 || firstValue instanceof cc.Vec3) {
        curve._lerp = DynamicAnimCurve.prototype._lerpVector;
      } else if (firstValue.lerp) {
        curve._lerp = DynamicAnimCurve.prototype._lerpObject;
      }
    }

    return curve;
  },
  createTargetCurves: function createTargetCurves(target, curveData, curves) {
    var propsData = curveData.props;
    var compsData = curveData.comps;

    if (propsData) {
      for (var propPath in propsData) {
        var data = propsData[propPath];
        var curve = this.createPropCurve(target, propPath, data);
        curves.push(curve);
      }
    }

    if (compsData) {
      for (var compName in compsData) {
        var comp = target.getComponent(compName);

        if (!comp) {
          continue;
        }

        var compData = compsData[compName];

        for (var _propPath in compData) {
          var _data = compData[_propPath];

          var _curve = this.createPropCurve(comp, _propPath, _data);

          curves.push(_curve);
        }
      }
    }
  },
  createCurves: function createCurves(state, root) {
    var curveData = this.curveData;
    var childrenCurveDatas = curveData.paths;
    var curves = [];
    this.createTargetCurves(root, curveData, curves);

    for (var namePath in childrenCurveDatas) {
      var target = cc.find(namePath, root);

      if (!target) {
        continue;
      }

      var childCurveDatas = childrenCurveDatas[namePath];
      this.createTargetCurves(target, childCurveDatas, curves);
    }

    return curves;
  }
});
cc.AnimationClip = module.exports = AnimationClip;
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_engine__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFuaW1hdGlvbi1jbGlwLmpzIl0sIm5hbWVzIjpbIldyYXBNb2RlIiwicmVxdWlyZSIsIkR5bmFtaWNBbmltQ3VydmUiLCJxdWlja0ZpbmRJbmRleCIsInNhbXBsZU1vdGlvblBhdGhzIiwiYmluYXJ5U2VhcmNoIiwiYmluYXJ5U2VhcmNoRXBzaWxvbiIsIkFuaW1hdGlvbkNsaXAiLCJjYyIsIkNsYXNzIiwibmFtZSIsIkFzc2V0IiwicHJvcGVydGllcyIsIl9kdXJhdGlvbiIsInR5cGUiLCJGbG9hdCIsImR1cmF0aW9uIiwiZ2V0Iiwic2FtcGxlIiwic3BlZWQiLCJ3cmFwTW9kZSIsIk5vcm1hbCIsImN1cnZlRGF0YSIsInZpc2libGUiLCJldmVudHMiLCJzdGF0aWNzIiwiY3JlYXRlV2l0aFNwcml0ZUZyYW1lcyIsInNwcml0ZUZyYW1lcyIsIkFycmF5IiwiaXNBcnJheSIsImVycm9ySUQiLCJjbGlwIiwibGVuZ3RoIiwiZnJhbWVzIiwic3RlcCIsImkiLCJsIiwiZnJhbWUiLCJ2YWx1ZSIsImNvbXBzIiwib25Mb2FkIiwiTnVtYmVyIiwicGFyc2VGbG9hdCIsInBhcnNlSW50IiwiZnJhbWVSYXRlIiwiY3JlYXRlUHJvcEN1cnZlIiwidGFyZ2V0IiwicHJvcFBhdGgiLCJrZXlmcmFtZXMiLCJtb3Rpb25QYXRocyIsImlzTW90aW9uUGF0aFByb3AiLCJOb2RlIiwiY3VydmUiLCJwcm9wIiwia2V5ZnJhbWUiLCJyYXRpbyIsInJhdGlvcyIsInB1c2giLCJtb3Rpb25QYXRoIiwiY3VydmVWYWx1ZSIsInZhbHVlcyIsImN1cnZlVHlwZXMiLCJ0eXBlcyIsIkxpbmVhciIsIkJlemllciIsImN1cnJSYXRpb0RpZiIsImxhc3RSYXRpb0RpZiIsImNhbk9wdGltaXplIiwiRVBTSUxPTiIsIk1hdGgiLCJhYnMiLCJfZmluZEZyYW1lSW5kZXgiLCJmaXJzdFZhbHVlIiwidW5kZWZpbmVkIiwiX2xlcnAiLCJwcm90b3R5cGUiLCJfbGVycE51bWJlciIsIlF1YXQiLCJfbGVycFF1YXQiLCJWZWMyIiwiVmVjMyIsIl9sZXJwVmVjdG9yIiwibGVycCIsIl9sZXJwT2JqZWN0IiwiY3JlYXRlVGFyZ2V0Q3VydmVzIiwiY3VydmVzIiwicHJvcHNEYXRhIiwicHJvcHMiLCJjb21wc0RhdGEiLCJkYXRhIiwiY29tcE5hbWUiLCJjb21wIiwiZ2V0Q29tcG9uZW50IiwiY29tcERhdGEiLCJjcmVhdGVDdXJ2ZXMiLCJzdGF0ZSIsInJvb3QiLCJjaGlsZHJlbkN1cnZlRGF0YXMiLCJwYXRocyIsIm5hbWVQYXRoIiwiZmluZCIsImNoaWxkQ3VydmVEYXRhcyIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBeUJBLElBQU1BLFFBQVEsR0FBR0MsT0FBTyxDQUFDLFNBQUQsQ0FBUCxDQUFtQkQsUUFBcEM7O2VBQzZDQyxPQUFPLENBQUMsb0JBQUQ7SUFBNUNDLDRCQUFBQTtJQUFrQkMsMEJBQUFBOztBQUMxQixJQUFNQyxpQkFBaUIsR0FBR0gsT0FBTyxDQUFDLHNCQUFELENBQVAsQ0FBZ0NHLGlCQUExRDs7QUFDQSxJQUFNQyxZQUFZLEdBQUdKLE9BQU8sQ0FBQyw2QkFBRCxDQUFQLENBQXVDSyxtQkFBNUQ7QUFFQTs7Ozs7Ozs7QUFNQSxJQUFJQyxhQUFhLEdBQUdDLEVBQUUsQ0FBQ0MsS0FBSCxDQUFTO0FBQ3pCQyxFQUFBQSxJQUFJLEVBQUUsa0JBRG1CO0FBRXpCLGFBQVNGLEVBQUUsQ0FBQ0csS0FGYTtBQUl6QkMsRUFBQUEsVUFBVSxFQUFFO0FBQ1JDLElBQUFBLFNBQVMsRUFBRTtBQUNQLGlCQUFTLENBREY7QUFFUEMsTUFBQUEsSUFBSSxFQUFFTixFQUFFLENBQUNPO0FBRkYsS0FESDs7QUFNUjs7Ozs7O0FBTUFDLElBQUFBLFFBQVEsRUFBRTtBQUNOQyxNQUFBQSxHQUFHLEVBQUUsZUFBWTtBQUFFLGVBQU8sS0FBS0osU0FBWjtBQUF3QjtBQURyQyxLQVpGOztBQWdCUjs7Ozs7O0FBTUFL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VUFBSW5ELE1BQU0sR0FBR3RDLEVBQUUsQ0FBQzRGLElBQUgsQ0FBUUQsUUFBUixFQUFrQkgsSUFBbEIsQ0FBYjs7QUFFQSxVQUFJLENBQUNsRCxNQUFMLEVBQWE7QUFDVDtBQUNIOztBQUVELFVBQUl1RCxlQUFlLEdBQUdKLGtCQUFrQixDQUFDRSxRQUFELENBQXhDO0FBQ0EsV0FBS2Ysa0JBQUwsQ0FBd0J0QyxNQUF4QixFQUFnQ3VELGVBQWhDLEVBQWlEaEIsTUFBakQ7QUFDSDs7QUFFRCxXQUFPQSxNQUFQO0FBQ0g7QUF6UXdCLENBQVQsQ0FBcEI7QUE0UUE3RSxFQUFFLENBQUNELGFBQUgsR0FBbUIrRixNQUFNLENBQUNDLE9BQVAsR0FBaUJoRyxhQUFwQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gQ29weXJpZ2h0IChjKSAyMDE3LTIwMTggWGlhbWVuIFlhamkgU29mdHdhcmUgQ28uLCBMdGQuXG5cbiBodHRwczovL3d3dy5jb2Nvcy5jb20vXG5cbiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBlbmdpbmUgc291cmNlIGNvZGUgKHRoZSBcIlNvZnR3YXJlXCIpLCBhIGxpbWl0ZWQsXG4gd29ybGR3aWRlLCByb3lhbHR5LWZyZWUsIG5vbi1hc3NpZ25hYmxlLCByZXZvY2FibGUgYW5kIG5vbi1leGNsdXNpdmUgbGljZW5zZVxuIHRvIHVzZSBDb2NvcyBDcmVhdG9yIHNvbGVseSB0byBkZXZlbG9wIGdhbWVzIG9uIHlvdXIgdGFyZ2V0IHBsYXRmb3Jtcy4gWW91IHNoYWxsXG4gbm90IHVzZSBDb2NvcyBDcmVhdG9yIHNvZnR3YXJlIGZvciBkZXZlbG9waW5nIG90aGVyIHNvZnR3YXJlIG9yIHRvb2xzIHRoYXQnc1xuIHVzZWQgZm9yIGRldmVsb3BpbmcgZ2FtZXMuIFlvdSBhcmUgbm90IGdyYW50ZWQgdG8gcHVibGlzaCwgZGlzdHJpYnV0ZSxcbiBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgQ29jb3MgQ3JlYXRvci5cblxuIFRoZSBzb2Z0d2FyZSBvciB0b29scyBpbiB0aGlzIExpY2Vuc2UgQWdyZWVtZW50IGFyZSBsaWNlbnNlZCwgbm90IHNvbGQuXG4gWGlhbWVuIFlhamkgU29mdHdhcmUgQ28uLCBMdGQuIHJlc2VydmVzIGFsbCByaWdodHMgbm90IGV4cHJlc3NseSBncmFudGVkIHRvIHlvdS5cblxuIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gVEhFIFNPRlRXQVJFLlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbmNvbnN0IFdyYXBNb2RlID0gcmVxdWlyZSgnLi90eXBlcycpLldyYXBNb2RlO1xuY29uc3QgeyBEeW5hbWljQW5pbUN1cnZlLCBxdWlja0ZpbmRJbmRleCB9ID0gcmVxdWlyZSgnLi9hbmltYXRpb24tY3VydmVzJyk7XG5jb25zdCBzYW1wbGVNb3Rpb25QYXRocyA9IHJlcXVpcmUoJy4vbW90aW9uLXBhdGgtaGVscGVyJykuc2FtcGxlTW90aW9uUGF0aHM7XG5jb25zdCBiaW5hcnlTZWFyY2ggPSByZXF1aXJlKCcuLi9jb3JlL3V0aWxzL2JpbmFyeS1zZWFyY2gnKS5iaW5hcnlTZWFyY2hFcHNpbG9uO1xuXG4vKipcbiAqICEjZW4gQ2xhc3MgZm9yIGFuaW1hdGlvbiBkYXRhIGhhbmRsaW5nLlxuICogISN6aCDliqjnlLvliarovpHvvIznlKjkuo7lrZjlgqjliqjnlLvmlbDmja7jgIJcbiAqIEBjbGFzcyBBbmltYXRpb25DbGlwXG4gKiBAZXh0ZW5kcyBBc3NldFxuICovXG52YXIgQW5pbWF0aW9uQ2xpcCA9IGNjLkNsYXNzKHtcbiAgICBuYW1lOiAnY2MuQW5pbWF0aW9uQ2xpcCcsXG4gICAgZXh0ZW5kczogY2MuQXNzZXQsXG5cbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIF9kdXJhdGlvbjoge1xuICAgICAgICAgICAgZGVmYXVsdDogMCxcbiAgICAgICAgICAgIHR5cGU6IGNjLkZsb2F0LFxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiAhI2VuIER1cmF0aW9uIG9mIHRoaXMgYW5pbWF0aW9uLlxuICAgICAgICAgKiAhI3poIOWKqOeUu+eahOaMgee7reaXtumXtOOAglxuICAgICAgICAgKiBAcHJvcGVydHkgZHVyYXRpb25cbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGR1cmF0aW9uOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2R1cmF0aW9uOyB9LFxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiAhI2VuIEZyYW1lUmF0ZSBvZiB0aGlzIGFuaW1hdGlvbi5cbiAgICAgICAgICogISN6aCDliqjnlLvnmoTluKfpgJ/njofjgIJcbiAgICAgICAgICogQHByb3BlcnR5IHNhbXBsZVxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgc2FtcGxlOiB7XG4gICAgICAgICAgICBkZWZhdWx0OiA2MCxcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogISNlbiBTcGVlZCBvZiB0aGlzIGFuaW1hdGlvbi5cbiAgICAgICAgICogISN6aCDliqjnlLvnmoTmkq3mlL7pgJ/luqbjgIJcbiAgICAgICAgICogQHByb3BlcnR5IHNwZWVkXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBzcGVlZDoge1xuICAgICAgICAgICAgZGVmYXVsdDogMVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiAhI2VuIFdyYXBNb2RlIG9mIHRoaXMgYW5pbWF0aW9uLlxuICAgICAgICAgKiAhI3poIOWKqOeUu+eahOW+queOr+aooeW8j+OAglxuICAgICAgICAgKiBAcHJvcGVydHkgd3JhcE1vZGVcbiAgICAgICAgICogQHR5cGUge1dyYXBNb2RlfVxuICAgICAgICAgKi9cbiAgICAgICAgd3JhcE1vZGU6IHtcbiAgICAgICAgICAgIGRlZmF1bHQ6IFdyYXBNb2RlLk5vcm1hbFxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiAhI2VuIEN1cnZlIGRhdGEuXG4gICAgICAgICAqICEjemgg5puy57q/5pWw5o2u44CCXG4gICAgICAgICAqIEBwcm9wZXJ0eSBjdXJ2ZURhdGFcbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICogQGV4YW1wbGUge0BsaW5rIGNvY29zMmQvY29yZS9hbmltYXRpb24tY2xpcC9jdXJ2ZS1kYXRhLmpzfVxuICAgICAgICAgKi9cbiAgICAgICAgY3VydmVEYXRhOiB7XG4gICAgICAgICAgICBkZWZhdWx0OiB7fSxcbiAgICAgICAgICAgIHZpc2libGU6IGZhbHNlLFxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiAhI2VuIEV2ZW50IGRhdGEuXG4gICAgICAgICAqICEjemgg5LqL5Lu25pWw5o2u44CCXG4gICAgICAgICAqIEBwcm9wZXJ0eSBldmVudHNcbiAgICAgICAgICogQHR5cGUge09iamVjdFtdfVxuICAgICAgICAgKiBAZXhhbXBsZSB7QGxpbmsgY29jb3MyZC9jb3JlL2FuaW1hdGlvbi1jbGlwL2V2ZW50LWRhdGEuanN9XG4gICAgICAgICAqIEB0eXBlc2NyaXB0IGV2ZW50czoge2ZyYW1lOiBudW1iZXIsIGZ1bmM6IHN0cmluZywgcGFyYW1zOiBzdHJpbmdbXX1bXVxuICAgICAgICAgKi9cbiAgICAgICAgZXZlbnRzOiB7XG4gICAgICAgICAgICBkZWZhdWx0OiBbXSxcbiAgICAgICAgICAgIHZpc2libGU6IGZhbHNlLFxuICAgICAgICB9XG4gICAgfSxcblxuICAgIHN0YXRpY3M6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqICEjZW4gQ3JhdGUgY2xpcCB3aXRoIGEgc2V0IG9mIHNwcml0ZSBmcmFtZXNcbiAgICAgICAgICogISN6aCDkvb/nlKjkuIDnu4Tluo/liJfluKflm77niYfmnaXliJvlu7rliqjnlLvliarovpFcbiAgICAgICAgICogQG1ldGhvZCBjcmVhdGVXaXRoU3ByaXRlRnJhbWVzXG4gICAgICAgICAqIEBwYXJhbSB7W1Nwcml0ZUZyYW1lXX0gc3ByaXRlRnJhbWVzXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzYW1wbGVcbiAgICAgICAgICogQHJldHVybiB7QW5pbWF0aW9uQ2xpcH1cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiB2YXIgY2xpcCA9IGNjLkFuaW1hdGlvbkNsaXAuY3JlYXRlV2l0aFNwcml0ZUZyYW1lcyhzcHJpdGVGcmFtZXMsIDEwKTtcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZVdpdGhTcHJpdGVGcmFtZXM6IGZ1bmN0aW9uIChzcHJpdGVGcmFtZXMsIHNhbXBsZSkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHNwcml0ZUZyYW1lcykpIHtcbiAgICAgICAgICAgICAgICBjYy5lcnJvcklEKDM5MDUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY2xpcCA9IG5ldyBBbmltYXRpb25DbGlwKCk7XG4gICAgICAgICAgICBjbGlwLnNhbXBsZSA9IHNhbXBsZSB8fCBjbGlwLnNhbXBsZTtcblxuICAgICAgICAgICAgY2xpcC5fZHVyYXRpb24gPSBzcHJpdGVGcmFtZXMubGVuZ3RoIC8gY2xpcC5zYW1wbGU7XG5cbiAgICAgICAgICAgIHZhciBmcmFtZXMgPSBbXTtcbiAgICAgICAgICAgIHZhciBzdGVwID0gMSAvIGNsaXAuc2FtcGxlO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHNwcml0ZUZyYW1lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmcmFtZXNbaV0gPSB7IGZyYW1lOiAoaSAqIHN0ZXApLCB2YWx1ZTogc3ByaXRlRnJhbWVzW2ldIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNsaXAuY3VydmVEYXRhID0ge1xuICAgICAgICAgICAgICAgIGNvbXBzOiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgICAnY2MuU3ByaXRlJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29tcG9uZW50IHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICdzcHJpdGVGcmFtZSc6IGZyYW1lc1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIGNsaXA7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgb25Mb2FkICgpIHtcbiAgICAgICAgdGhpcy5fZHVyYXRpb24gPSBOdW1iZXIucGFyc2VGbG9hdCh0aGlzLmR1cmF0aW9uKTtcbiAgICAgICAgdGhpcy5zcGVlZCA9IE51bWJlci5wYXJzZUZsb2F0KHRoaXMuc3BlZWQpO1xuICAgICAgICB0aGlzLndyYXBNb2RlID0gTnVtYmVyLnBhcnNlSW50KHRoaXMud3JhcE1vZGUpO1xuICAgICAgICB0aGlzLmZyYW1lUmF0ZSA9IE51bWJlci5wYXJzZUZsb2F0KHRoaXMuc2FtcGxlKTtcbiAgICB9LFxuXG4gICAgY3JlYXRlUHJvcEN1cnZlICh0YXJnZXQsIHByb3BQYXRoLCBrZXlmcmFtZXMpIHtcbiAgICAgICAgbGV0IG1vdGlvblBhdGhzID0gW107XG4gICAgICAgIGxldCBpc01vdGlvblBhdGhQcm9wID0gdGFyZ2V0IGluc3RhbmNlb2YgY2MuTm9kZSAmJiBwcm9wUGF0aCA9PT0gJ3Bvc2l0aW9uJztcblxuICAgICAgICBsZXQgY3VydmUgPSBuZXcgRHluYW1pY0FuaW1DdXJ2ZSgpO1xuXG4gICAgICAgIC8vIOe8k+WtmOebruagh+Wvueixoe+8jOaJgOS7pSBDb21wb25lbnQg5b+F6aG75LiA5byA5aeL6YO95Yib5bu65aW95bm25LiU5LiN6IO96L+Q6KGM5pe25Yqo5oCB5pu/5o2i4oCm4oCmXG4gICAgICAgIGN1cnZlLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgY3VydmUucHJvcCA9IHByb3BQYXRoO1xuXG4gICAgICAgIC8vIGZvciBlYWNoIGtleWZyYW1lc1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGtleWZyYW1lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBrZXlmcmFtZSA9IGtleWZyYW1lc1tpXTtcbiAgICAgICAgICAgIGxldCByYXRpbyA9IGtleWZyYW1lLmZyYW1lIC8gdGhpcy5kdXJhdGlvbjtcbiAgICAgICAgICAgIGN1cnZlLnJhdGlvcy5wdXNoKHJhdGlvKTtcblxuICAgICAgICAgICAgaWYgKGlzTW90aW9uUGF0aFByb3ApIHtcbiAgICAgICAgICAgICAgICBtb3Rpb25QYXRocy5wdXNoKGtleWZyYW1lLm1vdGlvblBhdGgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgY3VydmVWYWx1ZSA9IGtleWZyYW1lLnZhbHVlO1xuICAgICAgICAgICAgY3VydmUudmFsdWVzLnB1c2goY3VydmVWYWx1ZSk7XG5cbiAgICAgICAgICAgIGxldCBjdXJ2ZVR5cGVzID0ga2V5ZnJhbWUuY3VydmU7XG4gICAgICAgICAgICBpZiAoY3VydmVUeXBlcykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY3VydmVUeXBlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VydmUudHlwZXMucHVzaChjdXJ2ZVR5cGVzKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY3VydmVUeXBlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnZlVHlwZXNbMF0gPT09IGN1cnZlVHlwZXNbMV0gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnZlVHlwZXNbMl0gPT09IGN1cnZlVHlwZXNbM10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnZlLnR5cGVzLnB1c2goRHluYW1pY0FuaW1DdXJ2ZS5MaW5lYXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VydmUudHlwZXMucHVzaChEeW5hbWljQW5pbUN1cnZlLkJlemllcihjdXJ2ZVR5cGVzKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VydmUudHlwZXMucHVzaChEeW5hbWljQW5pbUN1cnZlLkxpbmVhcik7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmIChpc01vdGlvblBhdGhQcm9wKSB7XG4gICAgICAgICAgICBzYW1wbGVNb3Rpb25QYXRocyhtb3Rpb25QYXRocywgY3VydmUsIHRoaXMuZHVyYXRpb24sIHRoaXMuc2FtcGxlLCB0YXJnZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgZXZlcnkgcGllY2Ugb2YgcmF0aW9zIGFyZSB0aGUgc2FtZSwgd2UgY2FuIHVzZSB0aGUgcXVpY2sgZnVuY3Rpb24gdG8gZmluZCBmcmFtZSBpbmRleC5cbiAgICAgICAgbGV0IHJhdGlvcyA9IGN1cnZlLnJhdGlvcztcbiAgICAgICAgbGV0IGN1cnJSYXRpb0RpZiwgbGFzdFJhdGlvRGlmO1xuICAgICAgICBsZXQgY2FuT3B0aW1pemUgPSB0cnVlO1xuICAgICAgICBsZXQgRVBTSUxPTiA9IDFlLTY7XG4gICAgICAgIGZvciAobGV0IGkgPSAxLCBsID0gcmF0aW9zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgY3VyclJhdGlvRGlmID0gcmF0aW9zW2ldIC0gcmF0aW9zW2ktMV07XG4gICAgICAgICAgICBpZiAoaSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGxhc3RSYXRpb0RpZiA9IGN1cnJSYXRpb0RpZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKE1hdGguYWJzKGN1cnJSYXRpb0RpZiAtIGxhc3RSYXRpb0RpZikgPiBFUFNJTE9OKSB7XG4gICAgICAgICAgICAgICAgY2FuT3B0aW1pemUgPSBmYWxzZTsgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjdXJ2ZS5fZmluZEZyYW1lSW5kZXggPSBjYW5PcHRpbWl6ZSA/IHF1aWNrRmluZEluZGV4IDogYmluYXJ5U2VhcmNoO1xuXG4gICAgICAgIC8vIGZpbmQgdGhlIGxlcnAgZnVuY3Rpb25cbiAgICAgICAgbGV0IGZpcnN0VmFsdWUgPSBjdXJ2ZS52YWx1ZXNbMF07XG4gICAgICAgIGlmIChmaXJzdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgZmlyc3RWYWx1ZSAhPT0gbnVsbCAmJiAhY3VydmUuX2xlcnApIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZmlyc3RWYWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBjdXJ2ZS5fbGVycCA9IER5bmFtaWNBbmltQ3VydmUucHJvdG90eXBlLl9sZXJwTnVtYmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZmlyc3RWYWx1ZSBpbnN0YW5jZW9mIGNjLlF1YXQpIHtcbiAgICAgICAgICAgICAgICBjdXJ2ZS5fbGVycCA9IER5bmFtaWNBbmltQ3VydmUucHJvdG90eXBlLl9sZXJwUXVhdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGZpcnN0VmFsdWUgaW5zdGFuY2VvZiBjYy5WZWMyIHx8IGZpcnN0VmFsdWUgaW5zdGFuY2VvZiBjYy5WZWMzKSB7XG4gICAgICAgICAgICAgICAgY3VydmUuX2xlcnAgPSBEeW5hbWljQW5pbUN1cnZlLnByb3RvdHlwZS5fbGVycFZlY3RvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGZpcnN0VmFsdWUubGVycCkge1xuICAgICAgICAgICAgICAgIGN1cnZlLl9sZXJwID0gRHluYW1pY0FuaW1DdXJ2ZS5wcm90b3R5cGUuX2xlcnBPYmplY3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY3VydmU7XG4gICAgfSxcblxuICAgIGNyZWF0ZVRhcmdldEN1cnZlcyAodGFyZ2V0LCBjdXJ2ZURhdGEsIGN1cnZlcykge1xuICAgICAgICBsZXQgcHJvcHNEYXRhID0gY3VydmVEYXRhLnByb3BzO1xuICAgICAgICBsZXQgY29tcHNEYXRhID0gY3VydmVEYXRhLmNvbXBzO1xuXG4gICAgICAgIGlmIChwcm9wc0RhdGEpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHByb3BQYXRoIGluIHByb3BzRGF0YSkge1xuICAgICAgICAgICAgICAgIGxldCBkYXRhID0gcHJvcHNEYXRhW3Byb3BQYXRoXTtcbiAgICAgICAgICAgICAgICBsZXQgY3VydmUgPSB0aGlzLmNyZWF0ZVByb3BDdXJ2ZSh0YXJnZXQsIHByb3BQYXRoLCBkYXRhKTtcblxuICAgICAgICAgICAgICAgIGN1cnZlcy5wdXNoKGN1cnZlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb21wc0RhdGEpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGNvbXBOYW1lIGluIGNvbXBzRGF0YSkge1xuICAgICAgICAgICAgICAgIGxldCBjb21wID0gdGFyZ2V0LmdldENvbXBvbmVudChjb21wTmFtZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWNvbXApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGV0IGNvbXBEYXRhID0gY29tcHNEYXRhW2NvbXBOYW1lXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBwcm9wUGF0aCBpbiBjb21wRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZGF0YSA9IGNvbXBEYXRhW3Byb3BQYXRoXTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGN1cnZlID0gdGhpcy5jcmVhdGVQcm9wQ3VydmUoY29tcCwgcHJvcFBhdGgsIGRhdGEpO1xuXG4gICAgICAgICAgICAgICAgICAgIGN1cnZlcy5wdXNoKGN1cnZlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgY3JlYXRlQ3VydmVzIChzdGF0ZSwgcm9vdCkge1xuICAgICAgICBsZXQgY3VydmVEYXRhID0gdGhpcy5jdXJ2ZURhdGE7XG4gICAgICAgIGxldCBjaGlsZHJlbkN1cnZlRGF0YXMgPSBjdXJ2ZURhdGEucGF0aHM7XG4gICAgICAgIGxldCBjdXJ2ZXMgPSBbXTtcblxuICAgICAgICB0aGlzLmNyZWF0ZVRhcmdldEN1cnZlcyhyb290LCBjdXJ2ZURhdGEsIGN1cnZlcyk7XG5cbiAgICAgICAgZm9yIChsZXQgbmFtZVBhdGggaW4gY2hpbGRyZW5DdXJ2ZURhdGFzKSB7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gY2MuZmluZChuYW1lUGF0aCwgcm9vdCk7XG5cbiAgICAgICAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBjaGlsZEN1cnZlRGF0YXMgPSBjaGlsZHJlbkN1cnZlRGF0YXNbbmFtZVBhdGhdO1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVUYXJnZXRDdXJ2ZXModGFyZ2V0LCBjaGlsZEN1cnZlRGF0YXMsIGN1cnZlcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY3VydmVzO1xuICAgIH1cbn0pO1xuXG5jYy5BbmltYXRpb25DbGlwID0gbW9kdWxlLmV4cG9ydHMgPSBBbmltYXRpb25DbGlwO1xuIl19